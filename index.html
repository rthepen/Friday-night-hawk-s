<!DOCTYPE html>
<html lang="nl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Friday-night-hawk-s Timer v1.31.242</title>
    <link rel="icon" href="FNH logo.jpg" type="image/jpeg">
    <link rel="apple-touch-icon" href="FNH logo.jpg">
    <!-- script src="workout_data.js"></script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <script>
        // FIX: Ensure jsPDF is available globally for autotable
        window.jsPDF = window.jspdf.jsPDF;
    </script>
    <style>
        :root {
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --app-height: 100dvh;

            /* Premium Sport Palette */
            --bg-main: #000000;
            --bg-secondary: #0a0a0a;

            /* Glassmorphism */
            --bg-card: rgba(28, 28, 30, 0.65);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-blur: 25px;

            /* Accents */
            --accent-primary: #30D158;
            /* Neon Green */
            --accent-secondary: #0A84FF;
            /* Electric Blue */
            --accent-danger: #FF453A;
            --accent-warm: #FF9F0A;

            /* Text */
            --text-primary: #FFFFFF;
            --text-secondary: #98989d;
            --text-tertiary: #636366;

            /* Properties */
            --radius-card: 24px;
            --radius-btn: 18px;
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;

            /* Shadows */
            --glow-primary: 0 0 20px rgba(48, 209, 88, 0.3);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-main);
            color: var(--text-primary);
            font-family: var(--font-main);
            text-align: center;
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* Prevent scrolling */
            height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior: none;
            transition: background-color 0.3s ease;
        }

        /* --- HOURGLASS BACKGROUND --- */
        #hourglass-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-color: #000;
            /* Start black */
            pointer-events: none;
        }

        #hourglass-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background-color: #30D158;
            /* Default green */
            transition: height 1s linear, background-color 0.5s ease;
            box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.5);
            /* Soft top edge */
        }

        .container {
            padding: calc(10px + var(--safe-top)) 10px calc(10px + var(--safe-bottom)) 10px;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        /* --- INTRO BANNER --- */
        .intro-banner {
            background: linear-gradient(135deg, rgba(44, 44, 46, 0.8) 0%, rgba(28, 28, 30, 0.9) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-card);
            padding: 24px;
            margin-top: 10px;
            margin-bottom: 30px;
            box-shadow: var(--shadow-card);
        }

        .intro-title {
            font-size: 14px;
            font-weight: 900;
            color: var(--accent-primary);
            text-transform: uppercase;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }

        .intro-text {
            font-size: 13px;
            color: #ccc;
            line-height: 1.4;
        }

        /* --- LOGO & HEADER --- */
        .logo-container {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }

        .app-logo {
            width: 120px;
            height: auto;
            border-radius: 50%;
            border: 2px solid #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #222;
        }

        .app-header {
            font-size: 18px;
            font-weight: 900;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: -0.5px;
            text-align: left;
        }

        .version-tag {
            font-size: 11px;
            color: #30D158;
            background: #1c1c1e;
            padding: 2px 5px;
            border-radius: 4px;
            vertical-align: middle;
            margin-left: 5px;
            font-weight: bold;
            border: 1px solid #333;
        }

        .header-buttons {
            display: flex;
            gap: 5px;
        }

        .btn-header {
            border: none;
            border-radius: 20px;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: opacity 0.2s;
        }

        .btn-header:active {
            opacity: 0.6;
        }

        .btn-save {
            background: #0A84FF;
            color: white;
        }

        .btn-reset {
            background: #333;
            color: #ccc;
            border: 1px solid #444;
        }

        .btn-share-app {
            background: #BF5AF2;
            color: white;
        }

        /* --- GRID SYSTEMS --- */
        .compact-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            width: 100%;
            margin-bottom: 10px;
        }

        .bonus-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1.5fr;
            gap: 5px;
            width: 100%;
            margin-bottom: 8px;
            align-items: end;
        }

        .half-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            width: 100%;
            margin-bottom: 15px;
        }

        .select-group {
            display: flex;
            flex-direction: column;
            min-width: 0;
            justify-content: space-between;
        }

        label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
            text-align: left;
            white-space: normal;
            font-weight: 600;
            line-height: 1.3;
        }

        /* --- CARDS & INPUTS --- */
        .card-group {
            background: var(--bg-card);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-radius: var(--radius-card);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card-group:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        select.compact-select,
        input[type="time"],
        input[type="text"],
        input[type="number"],
        .text-input-trigger,
        select.text-input {
            width: 100%;
            padding: 16px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-primary);
            font-size: 17px;
            font-weight: 600;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            appearance: none;
            -webkit-appearance: none;
            text-align: center;
        }

        select.compact-select:focus,
        input:focus {
            background: rgba(0, 0, 0, 0.5);
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 4px rgba(48, 209, 88, 0.1);
            outline: none;
            transform: scale(1.01);
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        /* --- TOGGLES (Segmented Control) --- */
        .toggle-container {
            display: flex;
            background: #2C2C2E;
            border-radius: 99px;
            /* Pill shape */
            padding: 4px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .toggle-btn {
            flex: 1;
            padding: 10px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-weight: 600;
            border-radius: 99px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .toggle-btn.active {
            background: #636366;
            /* Lighter grey for active state in dark mode */
            background: var(--text-primary);
            color: #000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* --- BONUS ROW ALIGNMENT --- */
        .bonus-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .bonus-row input {
            flex: 2;
            /* Check wide name */
            min-width: 0;
        }

        .bonus-row select:nth-of-type(1) {
            flex: 1;
            /* Duration: Keep consistent width */
            min-width: 80px;
            /* Force minimum width */
        }

        .bonus-row select:nth-of-type(2) {
            flex: 2;
            /* Frequency: Wide */
            min-width: 0;
        }

        /* --- SECTIONS (Cards) --- */
        .speech-options,
        .resume-options,
        .extra-options {
            background: var(--bg-card);
            border-radius: var(--radius-card);
            padding: 20px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            text-align: left;
        }

        .resume-options,
        .extra-options {
            border-color: rgba(255, 255, 255, 0.05);
            margin-top: 15px;
            margin-bottom: 20px;
        }

        .category-header {
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 12px;
            font-weight: 900;
            color: #30D158;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .category-header:first-child {
            margin-top: 0;
        }

        .switch-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
        }

        .switch-label {
            font-size: 14px;
            color: #fff;
            flex: 1;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
            flex-shrink: 0;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 30px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #30D158;
        }

        input:checked+.slider:before {
            transform: translateX(16px);
        }

        /* Custom Text Input (Read only trigger) */
        .text-input-trigger {
            width: 100%;
            background: #2a2a2c;
            border: 1px solid #444;
            color: #ccc;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 15px;
            margin-top: 5px;
            white-space: pre-wrap;
            overflow: visible;
            min-height: 80px;
            line-height: 1.4;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .text-input-trigger:active {
            background: #3a3a3c;
        }

        /* Custom Text Input (Real select for coach) */
        select.text-input {
            width: 100%;
            background: #2a2a2c;
            border: 1px solid #444;
            color: #ccc;
            padding: 8px;
            border-radius: 6px;
            font-size: 13px;
            margin-bottom: 10px;
            margin-top: 2px;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right .7em top 50%;
            background-size: .65em auto;
        }

        /* --- COLLAPSIBLE (Resume only) --- */
        .collapsible-header {
            background: #2c2c2e;
            padding: 10px;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapsible-header:hover {
            background: #3a3a3c;
        }

        .collapsible-content {
            padding: 10px;
            background: #151516;
            border-radius: 6px;
            margin-top: 5px;
        }

        .collapsible-content.hidden {
            display: none;
        }

        .arrow {
            font-size: 10px;
            transition: transform 0.2s;
        }

        .open .arrow {
            transform: rotate(180deg);
        }


        /* --- BUTTONS --- */
        button.action-btn {
            width: 100%;
            padding: 20px;
            font-size: 20px;
            font-weight: 800;
            border: none;
            border-radius: var(--radius-btn);
            cursor: pointer;
            margin-top: 15px;
            margin-bottom: 30px;
            flex-shrink: 0;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            overflow: hidden;
        }

        button.action-btn:active {
            transform: scale(0.96);
        }

        button.action-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.15), transparent);
            opacity: 0;
            transition: opacity 0.2s;
        }

        button.action-btn:hover::after {
            opacity: 1;
        }

        .btn-start {
            background: linear-gradient(135deg, #32d74b 0%, #28cd41 100%);
            color: #000;
            box-shadow: 0 8px 25px rgba(40, 205, 65, 0.4);
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .btn-start:hover {
            box-shadow: 0 12px 30px rgba(40, 205, 65, 0.5);
            transform: translateY(-2px);
        }

        .btn-view-schedule {
            background-color: #0A84FF;
            color: white;
            margin-bottom: 10px;
        }



        /* Updated Control Buttons */
        /* Updated Control Buttons */
        .controls-container {
            background: rgba(28, 28, 30, 0.6) !important;
            /* Glass effect */
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px 25px !important;
            margin-bottom: 0 !important;
            gap: 20px !important;
        }

        .btn-control {
            flex: 1;
            height: 80px;
            border: none;
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            border-radius: 24px;
            /* More rounded */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.25, 1, 0.5, 1);
        }

        .btn-control:active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
        }

        .btn-control.paused {
            background: rgba(255, 159, 10, 0.2);
            color: var(--accent-warm);
            border: 1px solid var(--accent-warm);
        }

        .btn-stop {
            color: var(--accent-danger);
            background: rgba(255, 69, 58, 0.15);
        }

        .btn-skip {
            font-size: 24px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 60px;
            /* Fixed width for small buttons */
            flex: 0 0 60px;
        }

        /* LIVE SCHEDULE TABLE */
        /* LIVE SCHEDULE TABLE (Timeline Style) */
        #live-schedule-container {
            width: 100%;
            background: var(--bg-main);
            /* Match body */
            margin-top: 0;
            padding: 20px 0 80px 0;
            border-top: none;
        }

        .live-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 8px;
            /* Gap between rows */
            padding: 0 15px;
        }

        .live-table th {
            text-transform: uppercase;
            font-size: 10px;
            color: var(--text-secondary);
            letter-spacing: 1px;
            padding-bottom: 10px;
            background: var(--bg-main);
        }

        .live-table td {
            padding: 16px;
            background: var(--bg-card);
            color: var(--text-primary);
            border: none;
        }

        .live-table tr td:first-child {
            border-top-left-radius: 16px;
            border-bottom-left-radius: 16px;
        }

        .live-table tr td:last-child {
            border-top-right-radius: 16px;
            border-bottom-right-radius: 16px;
        }

        .live-table tr.active-row td {
            background: #2C2C2E;
            color: #fff;
            box-shadow: 0 0 0 2px var(--accent-primary);
            /* Ring border */
        }

        .live-table tr.active-row td {
            border: none !important;
        }

        .live-table tr.active-row td:first-child {
            border-left: none;
        }

        /* Remove old border */

        .live-table tr.future-row td {
            opacity: 0.5;
            background: #111;
        }

        .live-table tr.past-row td {
            opacity: 0.2;
        }

        /* Audio Debug Log */
        #audio-debug-log {
            display: none;
            /* Hidden via user request */
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 320px;
            height: 150px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #444;
            border-radius: 8px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 8px;
            overflow-y: auto;
            z-index: 10000;
            pointer-events: none;
            /* display: flex; */
            flex-direction: column-reverse;
            /* Newest items at bottom */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        #audio-debug-log div {
            border-bottom: 1px solid #222;
            padding: 2px 0;
            white-space: pre-wrap;
        }

        /* Audio Debug Log */



        .live-table tr {
            cursor: pointer;
            transition: background 0.2s;
        }

        .live-table tr:active {
            background: #333;
        }


        /* High Z-Index for Modals */
        .modal-overlay,
        #schedule-modal,
        #exercise-selector-modal {
            z-index: 9999 !important;
            position: fixed;
            /* Ensure fixed positioning */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            /* Proper backdrop */
        }

        /* --- INFO BOX --- */
        .info-bar {
            background: #111;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid #333;
            flex-shrink: 0;
            margin-top: 5px;
            position: relative;
        }

        .btn-force-edit {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: #333;
            border: 1px solid #555;
            color: white;
            font-size: 12px;
            padding: 5px 10px;
            border-radius: 6px;
            cursor: pointer;
        }

        .exercise-click-target {
            padding: 8px 10px;
            border: 1px solid #333;
            border-radius: 6px;
            cursor: pointer;
            background: #222;
            color: #fff;
            min-height: 44px;
            /* Touch friendly */
            display: flex;
            align-items: center;
            user-select: none;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.1);
            transition: background 0.1s;
        }

        .exercise-click-target:active {
            background: #444;
            transform: scale(0.98);
        }

        /* --- LISTS --- */
        .schedule-list-wrapper {
            flex: 1;
            text-align: left;
            background: #000;
            border-top: 1px solid #222;
            overflow-y: auto;
            min-height: 100px;
        }

        .schedule-item {
            padding: 10px;
            border-bottom: 1px solid #1a1a1a;
            color: #555;
            display: flex;
            align-items: center;
            font-size: 14px;
        }

        .schedule-item.active {
            color: #fff;
            background: #1c1c1e;
            border-left: 4px solid #30D158;
        }

        .col-time {
            width: 110px;
            font-family: monospace;
            color: #888;
            font-size: 12px;
            flex-shrink: 0;
        }

        .col-desc {
            flex: 1;
            padding: 0 8px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .col-dur {
            width: 40px;
            text-align: right;
            font-weight: bold;
            flex-shrink: 0;
        }

        /* --- TIMER SCREEN (GYM MODE) --- */
        #timer-screen {
            display: none;
            /* Scroll Fix v1.14: Restore full height container for scrolling */
            height: 100%;
            width: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            flex-direction: column;
            padding-bottom: 20px;
        }

        /* PROGRESS RINGS */
        .timer-ring-container {
            position: relative;
            width: 80vw;
            max-width: 350px;
            aspect-ratio: 1;
            margin: 0 auto 10px auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .timer-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
            /* Start at top */
            pointer-events: none;
        }

        /* --- EXERCISE SELECTOR MODAL --- */
        #exercise-selector-modal .modal-content {
            max-width: 500px;
            width: 95vw;
            height: 80vh;
            display: flex;
            flex-direction: column;
            padding: 0;
            background: #1c1c1e;
            border: 1px solid #333;
        }

        .ex-modal-header {
            padding: 15px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ex-modal-body {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .ex-search-container {
            padding: 10px;
            background: #111;
            border-bottom: 1px solid #333;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        #ex-search-input {
            width: 100%;
            padding: 12px;
            background: #2c2c2e;
            border: none;
            color: #fff;
            border-radius: 8px;
            font-size: 16px;
        }

        .ex-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .ex-list-item {
            padding: 15px;
            border-bottom: 1px solid #2c2c2e;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ex-list-item:hover {
            background: #2c2c2e;
        }

        .ex-cat-tag {
            font-size: 10px;
            padding: 3px 6px;
            border-radius: 4px;
            background: #333;
            color: #aaa;
            margin-right: 10px;
        }

        .ex-detail-view {
            display: none;
            flex-direction: column;
            height: 100%;
            padding: 20px;
        }

        .ex-detail-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #30D158;
        }

        .ex-detail-meta {
            font-size: 13px;
            color: #888;
            margin-bottom: 15px;
        }

        .ex-detail-desc {
            font-size: 14px;
            line-height: 1.5;
            color: #ccc;
            margin-bottom: 20px;
            background: #222;
            padding: 10px;
            border-radius: 8px;
        }

        .ex-video-btn {
            background: #FF3B30;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            cursor: pointer;
            text-decoration: none;
            margin-bottom: 20px;
        }

        .ex-scope-section {
            margin-top: auto;
            border-top: 1px solid #333;
            padding-top: 15px;
        }

        .ex-scope-title {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 10px;
            display: block;
        }

        .ex-scope-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .scope-radio {
            display: flex;
            align-items: center;
            padding: 10px;
            background: #2c2c2e;
            border-radius: 8px;
            cursor: pointer;
        }

        .scope-radio input {
            margin-right: 10px;
            accent-color: #30D158;
            transform: scale(1.2);
        }

        .scope-label-main {
            font-weight: bold;
            color: white;
            font-size: 14px;
        }

        .scope-label-sub {
            font-size: 11px;
            color: #888;
            display: block;
        }

        /* Ring Styles */
        .ring-bg-outer {
            fill: none;
            stroke: rgba(255, 255, 255, 0.05);
            stroke-width: 4;
        }

        .ring-val-outer {
            fill: none;
            stroke: var(--accent-secondary);
            stroke-width: 4;
            stroke-linecap: round;
            filter: drop-shadow(0 0 8px rgba(10, 132, 255, 0.5));
            /* Glow */
            transition: stroke-dashoffset 0.5s linear;
        }

        .ring-bg-inner {
            fill: none;
            stroke: rgba(255, 255, 255, 0.05);
            stroke-width: 8;
        }

        .ring-val-inner {
            fill: none;
            stroke: #BF5AF2;
            stroke-width: 8;
            stroke-linecap: round;
            filter: drop-shadow(0 0 10px rgba(191, 90, 242, 0.6));
            /* Glow */
            transition: stroke-dashoffset 0.2s linear;
        }

        /* Text inside ring */
        .gym-big-time {
            font-size: 28vw;
            font-weight: bold;
            font-variant-numeric: tabular-nums;
            line-height: 0.9;
            letter-spacing: -5px;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 2;
            pointer-events: none;
            margin: 0;
        }

        @media (min-width: 600px) {
            .gym-big-time {
                font-size: 140px;
            }
        }

        /* COUNTDOWN GLOW FIX (User Request) */
        #countdown {
            color: #ffffff !important;
            animation: epic-pulse 1s infinite ease-in-out;
            /* 60 BPM */
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            /* Neon Cyan base */
        }

        /* THE MAIN DISPLAY ZONE */
        .display-zone {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 10px;
            position: relative;
        }

        .gym-phase-title {
            font-size: 8vw;
            /* Normal size for long text */
            font-weight: 900;
            text-transform: uppercase;
            margin-bottom: 5px;
            opacity: 0.8;
            line-height: 1;
            position: relative;
            z-index: 1;
            pointer-events: none;
            transition: font-size 0.3s;
            /* Layout Fix: Reserve space for huge text */
            min-height: 14vw;
            display: flex;
            align-items: flex-end;
            justify-content: center;
        }

        .gym-phase-title.huge-text {
            font-size: 13vw;
        }

        .gym-phase-title.long-text {
            font-size: 5vw;
        }



        /* NEW STATS GRID STRUCTURE */
        .stats-wrapper {
            width: 95%;
            max-width: 600px;
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
            z-index: 50;
            pointer-events: none;
        }

        .stats-row-1 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }

        .stats-row-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
            /* CRITICAL: Re-enable clicks on the boxes */
            position: relative;
        }

        /* --- EDITABLE STYLES --- */
        .stat-box.editable {
            border: 2px solid #30D158;
            position: relative;
            z-index: 60;
        }

        .stat-box.editable:active {
            transform: scale(0.98);
            background: rgba(48, 209, 88, 0.2);
        }

        .edit-icon {
            position: absolute;
            top: 4px;
            right: 4px;
            font-size: 10px;
            color: #30D158;
        }

        .stat-label {
            font-size: 2.5vw;
            text-transform: uppercase;
            opacity: 0.8;
            font-weight: bold;
            margin-bottom: 2px;
            color: #ddd;
        }

        .stat-value {
            font-size: 6vw;
            /* Bigger as requested */
            font-weight: 900;
            font-variant-numeric: tabular-nums;
        }

        /* Fallback for very small or very large screens */
        @media (min-width: 600px) {
            .stat-label {
                font-size: 14px;
            }

            .stat-value {
                font-size: 36px;
            }

            .gym-phase-title {
                font-size: 40px;
            }

            .gym-phase-title.huge-text {
                font-size: 80px;
            }

            /* .gym-big-time {
                font-size: 180px;
            } */
        }

        .gym-next-info {
            font-size: 3vw;
            opacity: 0.7;
            margin-top: 20px;
            position: relative;
            z-index: 1;
            pointer-events: none;
        }

        .controls-container {
            flex: 0 0 100px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 20px;
            width: 100%;
            background: rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 100;
            /* Highest priority */
            pointer-events: auto;
            gap: 15px;
            /* Spacing between big buttons */
        }

        /* --- PHASE COLORS (Backgrounds) --- */
        /* --- PRE-WORKOUT EPIC EFFECTS --- */
        @keyframes epic-pulse {
            0% {
                transform: scale(1);
                text-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
                /* Cyan */
            }

            50% {
                transform: scale(1.02);
                text-shadow: 0 0 40px rgba(0, 255, 255, 0.6), 0 0 10px rgba(0, 255, 255, 0.8);
                /* Cyan Intense */
            }

            100% {
                transform: scale(1);
                text-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
                /* Cyan */
            }
        }

        .epic-timer {
            animation: epic-pulse 1s infinite ease-in-out;
            /* 60 BPM */
            font-variant-numeric: tabular-nums;
        }

        .epic-overlay {
            background: radial-gradient(circle at center, #222 0%, #000 100%) !important;
        }

        body.mode-work {
            background-color: #30D158;
            color: black;
        }

        body.mode-work .progress-fill {
            background: black;
        }

        body.mode-work .stat-box {
            background: rgba(0, 0, 0, 0.15);
            border-color: rgba(0, 0, 0, 0.2);
        }

        body.mode-work .stat-box.editable {
            border-color: #000;
        }

        body.mode-work .edit-icon {
            color: #000;
        }

        body.mode-work .stat-label {
            color: rgba(0, 0, 0, 0.6);
        }

        body.mode-rest {
            background-color: #FF9F0A;
            color: black;
        }

        body.mode-rest .progress-fill {
            background: black;
        }

        body.mode-rest .stat-box {
            background: rgba(0, 0, 0, 0.15);
            border-color: rgba(0, 0, 0, 0.2);
        }

        body.mode-rest .stat-box.editable {
            border-color: #000;
        }

        body.mode-rest .edit-icon {
            color: #000;
        }

        body.mode-rest .stat-label {
            color: rgba(0, 0, 0, 0.6);
        }

        body.mode-switch {
            background-color: #BF5AF2;
            color: white;
        }

        body.mode-long {
            background-color: #0A84FF;
            color: white;
        }

        body.mode-prep {
            background-color: #1c1c1e;
            color: white;
        }

        body.mode-finish {
            background-color: #FFD60A;
            color: black;
        }

        body.mode-pause {
            background-color: #333;
            color: white;
        }

        /* --- MODALS --- */
        /* --- MODALS --- */
        #pause-modal,
        #calc-modal,
        #speech-edit-modal,
        #schedule-modal,
        #edit-scope-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-glass);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--bg-card);
            padding: 25px;
            border-radius: var(--radius-card);
            width: 90%;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            color: var(--text-primary);
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* SPEECH MODAL FIX */
        #speech-edit-modal .modal-content {
            width: 98%;
            max-width: 98%;
            padding: 15px;
        }

        /* SCHEDULE MODAL STYLES */
        #schedule-modal .modal-content {
            max-width: 600px;
            width: 95%;
            text-align: left;
            padding: 15px;
            display: flex;
            flex-direction: column;
            height: 90vh;
        }

        .schedule-table-container {
            flex: 1;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid #333;
            border-radius: 8px;
        }

        .schedule-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .schedule-table th {
            background: #333;
            color: #fff;
            padding: 8px;
            text-align: left;
            position: sticky;
            top: 0;
        }

        .schedule-table td {
            padding: 8px;
            border-bottom: 1px solid #222;
            color: #ccc;
        }

        .schedule-table tr.row-work td {
            color: #fff;
            font-weight: bold;
        }

        .schedule-table tr.row-work input {
            background: #222;
            border: 1px solid #444;
            color: #30D158;
            width: 100%;
            padding: 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
        }

        .schedule-table tr.row-bonus td {
            color: #BF5AF2;
            font-weight: bold;
        }

        .modal-btn {
            display: block;
            width: 100%;
            padding: 15px;
            margin-top: 10px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            text-align: left;
            position: relative;
        }

        .modal-btn .btn-subtext {
            display: block;
            font-size: 11px;
            font-weight: normal;
            opacity: 0.7;
            margin-top: 2px;
        }

        .calc-input {
            width: 80px;
            font-size: 24px;
            padding: 10px;
            text-align: center;
            border-radius: 8px;
            border: 1px solid #555;
            background: #222;
            color: white;
            margin-bottom: 15px;
        }

        .option-desc {
            font-size: 13px;
            color: #ccc;
            margin-top: 2px;
            font-weight: normal;
        }

        /* SPEECH EDIT TEXTAREA */
        #speech-edit-area {
            width: 100%;
            min-height: 350px;
            background: #222;
            border: 1px solid #555;
            color: white;
            font-size: 16px;
            padding: 15px;
            border-radius: 8px;
            resize: none;
            margin-bottom: 15px;
            font-family: inherit;
            box-sizing: border-box;
        }

        .hidden {
            display: none !important;
        }

        /* SAFETY: Prevent Timer Screen leaks if markup is broken */
        #setup-screen #timer-screen,
        #setup-screen .controls-container,
        #setup-screen #pause-modal {
            display: none !important;
        }

        /* TRANSPARENT INPUT STYLES */
        .transparent-input {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            z-index: 20;
            cursor: pointer;
            border: none;
            padding: 0;
            margin: 0;
            appearance: none;
        }

        /* --- GENERATOR MODAL STYLES --- */
        #generator-modal .modal-content {
            max-width: 500px;
            width: 95%;
            padding: 0;
            display: flex;
            flex-direction: column;
            background: #1c1c1e;
            height: 85vh;
        }

        .gen-section {
            padding: 15px;
            border-bottom: 1px solid #333;
        }

        .gen-section-title {
            font-size: 13px;
            font-weight: 900;
            color: #BF5AF2;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .gen-checkbox-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            max-height: 150px;
            overflow-y: auto;
        }

        .gen-checkbox-item {
            background: #2c2c2e;
            padding: 8px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            font-size: 12px;
            color: #ccc;
            cursor: pointer;
            user-select: none;
        }

        .gen-checkbox-item input {
            margin-right: 8px;
            accent-color: #BF5AF2;
        }

        .gen-radio-group {
            display: flex;
            background: #2c2c2e;
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 5px;
        }

        .gen-radio-opt {
            flex: 1;
            text-align: center;
            padding: 8px;
            font-size: 12px;
            color: #888;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .gen-radio-opt.active {
            background: #BF5AF2;
            color: white;
            font-weight: bold;
        }

        .gen-btn-generate {
            background: linear-gradient(135deg, #BF5AF2, #5E5CE6);
            color: white;
            border: none;
            padding: 15px;
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-radius: 12px;
            margin: 15px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(191, 90, 242, 0.4);
        }
    </style>
</head>

<body>
    <!-- Hourglass Background -->
    <div id="hourglass-bg">
        <div id="hourglass-fill"></div>
    </div>

    <div id="setup-screen" class="container">

        <div class="logo-container">
            <img src="FNH logo.jpg" alt="FNH Logo" class="app-logo" onclick="applyFNHPreset()" style="cursor: pointer;">
        </div>

        <div class="header-row">
            <div class="app-header">
                FNH Timer <span class="version-tag">v1.31.242</span>
            </div>
            <div class="header-buttons">
                <button class="btn-header btn-reset" onclick="resetToDefaults()">🔄 Reset</button>
                <button class="btn-header btn-reset" style="background:#FF9F0A; color:white;"
                    onclick="applyTabataPreset()">⏱️ Tabata</button>
                <button class="btn-header btn-save" onclick="shareSettings()">💾 Save</button>
                <button class="btn-header btn-share-app" onclick="shareApp()">📤 Delen</button>
            </div>
        </div>

        <div style="font-size:12px; color:#666; text-transform:uppercase; margin-bottom:5px;">TIJDSINSTELLINGEN</div>

        <div class="compact-row">
            <div class="select-group">
                <label>Starttijd</label>
                <input type="time" id="startTimeValue" class="highlight-input"
                    onchange="syncTime('starttime'); saveToLocal();">
            </div>
            <div class="select-group">
                <label>Duur (min)</label>
                <select id="totalMin" class="compact-select highlight-input"
                    onchange="syncTime('duration'); saveToLocal();"></select>
            </div>
            <div class="select-group">
                <label>Eindtijd</label>
                <input type="time" id="endTimeValue" class="highlight-input"
                    onchange="syncTime('endtime'); saveToLocal();">
            </div>
        </div>

        <div class="compact-row">
            <div class="select-group">
                <label>Rondes</label>
                <select id="rounds" class="compact-select" onchange="calculateRealTime(); saveToLocal();"></select>
            </div>
            <div class="select-group">
                <label>Oefeningen</label>
                <select id="exercises" class="compact-select" onchange="calculateRealTime(); saveToLocal();"></select>
            </div>
            <div class="select-group">
                <label>Sets</label>
                <select id="sets" class="compact-select" onchange="calculateRealTime(); saveToLocal();"></select>
            </div>
        </div>

        <div class="compact-row">
            <div class="select-group">
                <label>Rust tussen rondes</label>
                <select id="roundRestSec" class="compact-select"
                    onchange="calculateRealTime(); saveToLocal();"></select>
            </div>
            <div class="select-group">
                <label>Rust tussen wisselen van oefening</label>
                <select id="exerciseRestSec" class="compact-select"
                    onchange="calculateRealTime(); saveToLocal();"></select>
            </div>
            <div class="select-group">
                <label>Rust tussen sets</label>
                <select id="restSec" class="compact-select" onchange="calculateRealTime(); saveToLocal();"></select>
            </div>
        </div>

        <div style="margin-bottom:15px; margin-top:5px;">
            <div
                style="font-size:11px; color:#888; margin-bottom:4px; text-align:left; font-weight:600; text-transform:uppercase;">
                EXTRA OEFENINGEN (BONUS)</div>
            <div style="font-size:11px; color:#aaa; margin-bottom:10px; text-align:left;">
                Bijv: Warming-up (eenmalig start), Spinning (begin elke ronde) of Toetje/Finisher (einde les).
            </div>

            <div class="bonus-row" id="bonus-row-1">
                <input type="text" id="bonus1-name" value="Bonus 1" class="text-input" style="text-align:left;"
                    oninput="saveToLocal()">
                <select id="bonus1-duration" class="compact-select"
                    onchange="calculateRealTime(); saveToLocal(); updateBonusVisibility();"></select>
                <select id="bonus1-freq" class="compact-select" onchange="calculateRealTime(); saveToLocal();"></select>
            </div>

            <div class="bonus-row" id="bonus-row-2">
                <input type="text" id="bonus2-name" value="Bonus 2" class="text-input" style="text-align:left;"
                    oninput="saveToLocal()">
                <select id="bonus2-duration" class="compact-select"
                    onchange="calculateRealTime(); saveToLocal(); updateBonusVisibility();"></select>
                <select id="bonus2-freq" class="compact-select" onchange="calculateRealTime(); saveToLocal();"></select>
            </div>

            <div class="bonus-row" id="bonus-row-3">
                <input type="text" id="bonus3-name" value="Bonus 3" class="text-input" style="text-align:left;"
                    oninput="saveToLocal()">
                <select id="bonus3-duration" class="compact-select"
                    onchange="calculateRealTime(); saveToLocal(); updateBonusVisibility();"></select>
                <select id="bonus3-freq" class="compact-select" onchange="calculateRealTime(); saveToLocal();"></select>
            </div>
        </div>

        <div class="info-bar" onclick="openSetupWorkAdjustment()" style="cursor:pointer;">
            <div style="font-size:12px; color:#888;">WERKTIJD PER SET</div>
            <div style="font-size:30px; font-weight:bold; color:#30D158;" id="live-calc-result">--</div>
            <div style="font-size:10px; color:#666; position:absolute; right:10px; top:10px;">✏️</div>

            <div id="live-calc-error" style="color:#FF453A; display:none; font-size:12px;">Onmogelijk schema!</div>
        </div>

        <div id="setup-work-adjust-modal" class="modal-overlay"
            style="display:none; align-items:center; justify-content:center;">
            <div class="modal-content" style="width:90%; max-width:400px; text-align:center;">
                <h2 style="margin-top:0;">Werktijd (Setup)</h2>
                <p style="color:#aaa; font-size:13px; margin-bottom:15px;">Pas de werktijd aan en kies wat er moet
                    veranderen.</p>

                <div style="background:#2c2c2e; padding:15px; border-radius:10px; margin-bottom:20px;">
                    <div style="font-size:12px; color:#888;">Nieuwe Werktijd</div>
                    <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
                        <button class="modal-btn" style="width:40px; height:40px; padding:0; background:#444;"
                            onclick="adjustSetupWorkInput(-5)">-5</button>
                        <input type="number" id="setup-work-input" value="45"
                            style="font-size:32px; background:transparent; border:none; color:white; font-weight:bold; text-align:center; width:80px; font-family: 'Outfit', sans-serif;"
                            onchange="calcSetupWorkDiff()">
                        <button class="modal-btn" style="width:40px; height:40px; padding:0; background:#444;"
                            onclick="adjustSetupWorkInput(5)">+5</button>
                    </div>
                    <div id="setup-work-diff" style="margin-top:5px; font-weight:bold; color:#0A84FF;">+0s per set</div>
                </div>

                <button class="modal-btn" id="btn-setup-duration" style="background: #0A84FF; color: white;"
                    onclick="applySetupWorkAdjustment('duration')">
                    🗓️ Pas Duur Aan
                    <span class="btn-subtext" id="sub-setup-duration">Totale tijd verandert</span>
                </button>

                <button class="modal-btn" id="btn-setup-rest" style="background: #FF9F0A; color: black;"
                    onclick="applySetupWorkAdjustment('rest')">
                    💤 Pas Rust Aan
                    <span class="btn-subtext" id="sub-setup-rest">Rust wordt korter/langer</span>
                </button>

                <button class="modal-btn" style="background: #333; color: #888; margin-top:15px; border:1px solid #444;"
                    onclick="closeSetupWorkAdjustment()">
                    ❌ Annuleren
                </button>
            </div>
        </div>

        <button class="action-btn btn-start" id="btn-start-app" onclick="startWorkout()">START TRAINING</button>

        <button class="action-btn btn-view-schedule" onclick="showScheduleModal()">📅 Bekijk & Bewerk Schema</button>



        <div class="resume-options" style="display:none;">
            <div class="collapsible-header resume-header open" onclick="toggleSection('sec-resume')">
                <div>Beginnen vanaf moment in training</div>
                <span class="arrow">▼</span>
            </div>
            <div id="sec-resume" class="collapsible-content">
                <div style="font-size:12px; color:#aaa; margin-bottom:8px;">Vul hieronder in waar je wilt starten.</div>

                <div class="compact-row">
                    <div class="select-group">
                        <label>Ronde</label>
                        <select id="start-round" class="compact-select"
                            onchange="saveToLocal(); calculateRealTime();"></select>
                    </div>
                    <div class="select-group">
                        <label>Oefening</label>
                        <select id="start-ex" class="compact-select"
                            onchange="saveToLocal(); calculateRealTime();"></select>
                    </div>
                    <div class="select-group">
                        <label>Set</label>
                        <select id="start-set" class="compact-select"
                            onchange="saveToLocal(); calculateRealTime();"></select>
                    </div>
                </div>

            </div>
        </div>



        <div style="text-align:left; padding:5px 0; font-size:12px; color:#666; margin-top:20px;">VOORBEELD SCHEMA
            (VANAF NU):</div>
        <div id="preview-list" class="schedule-list-wrapper">
        </div>

        <div class="intro-banner">
            <div class="intro-title">🦅 Welcome to the Friday Night Hawks!</div>
            <div class="intro-text">
                De legendarische triathlon: <b>Spinning 🚴 » Bootcamp 🏋️ » Zwemmen 🏊</b>.
                <br>Iedere vrijdagavond om 19:45. We sluiten af met <b>bitterballen</b> & gezelligheid! 🍖🍻
            </div>
        </div>

    </div>

    <div id="timer-screen" style="display:none !important;">




        <div class="display-zone">
            <div class="gym-phase-title" id="gym-phase-title">KLAARMAKEN</div>

            <div class="timer-ring-container">
                <svg class="timer-svg" viewBox="0 0 100 100">
                    <!-- Outer Ring (Total) -->
                    <circle class="ring-bg-outer" cx="50" cy="50" r="48"></circle>
                    <circle class="ring-val-outer" id="ring-total" cx="50" cy="50" r="48" stroke-dasharray="301.6"
                        stroke-dashoffset="0"></circle>

                    <!-- Inner Ring (Step) -->
                    <circle class="ring-bg-inner" cx="50" cy="50" r="40"></circle>
                    <circle class="ring-val-inner" id="ring-step" cx="50" cy="50" r="40" stroke-dasharray="251.3"
                        stroke-dashoffset="0"></circle>
                </svg>
                <div class="gym-big-time" id="countdown">10</div>
                <div id="circle-remaining"
                    style="position: absolute; top: 70%; left: 50%; transform: translate(-50%, -50%); font-size: 16px; color: #888; font-weight: bold;">
                    --m</div>
                <!-- NEW PERCENTAGE DISPLAY -->
                <div id="ring-percent"
                    style="position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); font-size: 14px; color: #555; font-weight: bold;">
                    0%
                </div>
            </div>

            <div class="stats-wrapper" id="gym-stats-container">
                <div class="stats-row-1">
                    <div class="stat-box editable">
                        <select id="jump-round" class="transparent-input" onchange="handleJump()"></select>
                        <div class="edit-icon">▼</div>
                        <div class="stat-label">Ronde</div>
                        <div class="stat-value" id="val-round">-</div>
                    </div>
                    <div class="stat-box editable">
                        <select id="jump-exercise" class="transparent-input" onchange="handleJump()"></select>
                        <div class="edit-icon">▼</div>
                        <div class="stat-label">Oefening</div>
                        <div class="stat-value" id="val-exercise">-</div>
                    </div>
                    <div class="stat-box editable">
                        <select id="jump-set" class="transparent-input" onchange="handleJump()"></select>
                        <div class="edit-icon">▼</div>
                        <div class="stat-label">Set</div>
                        <div class="stat-value" id="val-set">-</div>
                    </div>
                </div>
                <div class="stats-row-2">
                    <div class="stat-box editable" onclick="openLiveEndAdjustment()" style="cursor:pointer;">
                        <div class="edit-icon">🏁</div>
                        <div class="stat-label">Einde</div>
                        <div class="stat-value" id="val-endtime">--:--</div>
                    </div>
                    <div class="stat-box editable" onclick="openLiveWorkAdjustment()" style="cursor:pointer;">
                        <div class="edit-icon">⏱️</div>
                        <div class="stat-label">Werktijd</div>
                        <div class="stat-value" id="val-worktime">--s</div>
                    </div>
                </div>

                <div class="stats-row-3" style="display:flex; justify-content:space-between; margin-top:10px; gap:8px;">
                    <div class="stat-box editable" onclick="openLiveRestAdjustment('rest')"
                        style="cursor:pointer; flex:1;">
                        <div class="edit-icon">💤</div>
                        <div class="stat-label">Rust</div>
                        <div class="stat-value" id="val-rest">--s</div>
                    </div>
                    <div class="stat-box editable" onclick="openLiveRestAdjustment('rest-exercise')"
                        style="cursor:pointer; flex:1;">
                        <div class="edit-icon">🔀</div>
                        <div class="stat-label">Wissel</div>
                        <div class="stat-value" id="val-switch">--s</div>
                    </div>
                    <div class="stat-box editable" onclick="openLiveRestAdjustment('rest-long')"
                        style="cursor:pointer; flex:1;">
                        <div class="edit-icon">☕</div>
                        <div class="stat-label">Pauze Ronde</div>
                        <div class="stat-value" id="val-pause-round">--s</div>
                    </div>
                </div>
            </div>

            <div class="gym-next-info" id="gym-next-info">Hierna: Rust</div>
            <!-- NOW PLAYING (Relocated) -->
            <div id="gym-now-playing"
                style="font-size:13px; color:#888; margin-top:5px; height:18px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
            </div>
        </div>

        <div class="controls-container">
            <button class="btn-control btn-skip" onclick="handlePrevClick()">⏮</button>
            <button class="btn-control btn-pause" id="btn-pause" onclick="handlePauseClick()">⏸</button>
            <button class="btn-control btn-skip" onclick="handleNextClick()">⏭</button>
            <button class="btn-control btn-stop" onclick="confirmStop()">⏹</button>
        </div>

        <div id="live-schedule-container">
            <table class="live-table" id="live-table">
                <thead>
                    <tr>
                        <th style="width:60px;">Tijd</th>
                        <th>Activiteit</th>
                        <th style="width:50px; text-align:right;">Duur</th>
                    </tr>
                </thead>
                <tbody id="live-table-body"></tbody>
            </table>
        </div>
    </div>

    <div id="pause-modal" style="display:none;">
        <div class="modal-content">
            <h2 id="pause-modal-title" style="margin-top:0;">PAUZE VOORBIJ</h2>
            <p id="pause-msg-p" style="color:#aaa; font-size:13px; margin-bottom:15px;">Je hebt <span
                    id="pause-duration-display" style="color:white; font-weight:bold;">0s</span> gepauzeerd.</p>



            <button class="modal-btn"
                style="background: linear-gradient(135deg, #32d74b 0%, #28cd41 100%); color: #000; font-weight: 800; border: none; box-shadow: 0 5px 15px rgba(50, 215, 75, 0.4);"
                onclick="resolvePause('push')">
                ✅ Eindtijd verzetten
                <span class="btn-subtext" id="btn-text-push" style="color: rgba(0,0,0,0.6); font-weight:600;">...</span>
                <div style="font-size: 11px; font-weight: normal; opacity: 0.8; margin-top: 2px;">Werk- en rusttijden
                    blijven intact</div>
            </button>

            <button class="modal-btn" id="btn-catch-work" style="background: #0A84FF; color: white;"
                onclick="resolvePause('work')">
                ⏱️ Inhalen via Werktijd
                <span class="btn-subtext" id="btn-text-work">...</span>
            </button>

            <button class="modal-btn" id="btn-catch-rest" style="background: #FF9F0A; color: black;"
                onclick="resolvePause('rest')">
                💤 Inhalen via Rust (Set)
                <span class="btn-subtext" id="btn-text-rest">...</span>
            </button>

            <button class="modal-btn" id="btn-catch-switch" style="background: #BF5AF2; color: white;"
                onclick="resolvePause('switch')">
                🔀 Inhalen via Wissels
                <span class="btn-subtext" id="btn-text-switch">...</span>
            </button>

            <button class="modal-btn" id="btn-catch-round" style="background: #0A84FF; color: white;"
                onclick="resolvePause('round')">
                ☕ Inhalen via Ronde Rust
                <span class="btn-subtext" id="btn-text-round">...</span>
            </button>

            <button class="modal-btn" style="background: #333; color: #888; margin-top:15px; border:1px solid #444;"
                onclick="cancelPause()">
                ❌ Annuleren (Terug)
            </button>
        </div>
    </div>



    <div id="speech-edit-modal">
        <div class="modal-content">
            <h3 style="margin-top:0;">Spraak aanpassen</h3>
            <div style="font-size:12px; color:#aaa; margin-bottom:10px;">Gebruik | voor variatie</div>
            <textarea id="speech-edit-area"></textarea>
            <button class="modal-btn" style="background: #30D158; color: black;" onclick="saveSpeechEdit()">💾
                Opslaan</button>
            <button class="modal-btn" style="background: #333; color: white; margin-top:10px;"
                onclick="closeSpeechEdit()">Annuleren</button>
        </div>
    </div>

    <div id="live-end-adjust-modal" class="modal-overlay"
        style="display:none; align-items:center; justify-content:center;">
        <div class="modal-content" style="width:90%; max-width:400px; text-align:center;">
            <h2 style="margin-top:0;">Eindtijd Verzetten</h2>
            <p style="color:#aaa; font-size:13px; margin-bottom:15px;">Pas de eindtijd aan en kies hoe het verschil
                verdeeld wordt over de <b>resterende</b> oefeningen.</p>

            <div style="background:#2c2c2e; padding:15px; border-radius:10px; margin-bottom:20px;">
                <div style="font-size:12px; color:#888;">Nieuwe Eindtijd</div>
                <input type="time" id="live-adjust-input"
                    style="font-size:32px; background:transparent; border:none; color:white; font-weight:bold; text-align:center; width:100%; font-family: 'Outfit', sans-serif;"
                    onchange="calcLiveEndDiff()">
                <div id="live-adjust-diff" style="margin-top:5px; font-weight:bold; color:#0A84FF;">+0m 0s</div>
            </div>

            <button class="modal-btn" id="btn-live-work" style="background: #0A84FF; color: white;"
                onclick="applyLiveEndAdjustment('work')">
                ⏱️ Verdeel over Werk
                <span class="btn-subtext" id="sub-live-work">Effect: +/- 0s per set</span>
            </button>

            <button class="modal-btn" id="btn-live-rest" style="background: #FF9F0A; color: black;"
                onclick="applyLiveEndAdjustment('rest')">
                💤 Verdeel over Rust
                <span class="btn-subtext" id="sub-live-rest">Effect: +/- 0s per set</span>
            </button>

            <button class="modal-btn" id="btn-live-switch" style="background: #BF5AF2; color: white;"
                onclick="applyLiveEndAdjustment('switch')">
                🔀 Verdeel over Wissels
                <span class="btn-subtext" id="sub-live-switch">Effect: +/- 0s per wissel</span>
            </button>

            <button class="modal-btn" style="background: #333; color: #888; margin-top:15px; border:1px solid #444;"
                onclick="cancelLiveAdjustment()">
                ❌ Annuleren
            </button>
        </div>
    </div>

    <div id="live-work-adjust-modal" class="modal-overlay"
        style="display:none; align-items:center; justify-content:center;">
        <div class="modal-content" style="width:90%; max-width:400px; text-align:center;">
            <h2 style="margin-top:0;">Werktijd Aanpassen</h2>
            <p style="color:#aaa; font-size:13px; margin-bottom:15px;">Pas de tijd per set aan en kies hoe het verschil
                verrekend wordt.</p>

            <div style="background:#2c2c2e; padding:15px; border-radius:10px; margin-bottom:20px;">
                <div style="font-size:12px; color:#888;">Nieuwe Werktijd</div>
                <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
                    <button class="modal-btn" style="width:40px; height:40px; padding:0; background:#444;"
                        onclick="adjustLiveWorkInput(-5)">-5</button>
                    <input type="number" id="live-work-input" value="45"
                        style="font-size:32px; background:transparent; border:none; color:white; font-weight:bold; text-align:center; width:80px; font-family: 'Outfit', sans-serif;"
                        onchange="calcLiveWorkDiff()">
                    <button class="modal-btn" style="width:40px; height:40px; padding:0; background:#444;"
                        onclick="adjustLiveWorkInput(5)">+5</button>
                </div>
                <div id="live-work-diff" style="margin-top:5px; font-weight:bold; color:#0A84FF;">+0s per set</div>
            </div>

            <button class="modal-btn" id="btn-work-push" style="background: #0A84FF; color: white;"
                onclick="applyLiveWorkAdjustment('push')">
                🗓️ Verzet Eindtijd
                <span class="btn-subtext" id="sub-work-push">Eindtijd schuift op met Xm</span>
            </button>

            <button class="modal-btn" id="btn-work-rest" style="background: #FF9F0A; color: black;"
                onclick="applyLiveWorkAdjustment('rest')">
                💤 Compenseer met Rust
                <span class="btn-subtext" id="sub-work-rest">Rust wordt X seconden</span>
            </button>

            <button class="modal-btn" id="btn-work-switch" style="background: #BF5AF2; color: white;"
                onclick="applyLiveWorkAdjustment('switch')">
                🔀 Compenseer met Wissels
                <span class="btn-subtext" id="sub-work-switch">Wissel wordt X seconden</span>
            </button>

            <button class="modal-btn" style="background: #333; color: #888; margin-top:15px; border:1px solid #444;"
                onclick="cancelLiveWorkAdjustment()">
                ❌ Annuleren
            </button>
        </div>
    </div>

    <div id="live-rest-adjust-modal" class="modal-overlay"
        style="display:none; align-items:center; justify-content:center;">
        <div class="modal-content" style="width:90%; max-width:400px; text-align:center;">
            <h2 style="margin-top:0;"><span id="live-rest-type-label">Rust</span> Aanpassen</h2>
            <p style="color:#aaa; font-size:13px; margin-bottom:15px;">Pas de tijd aan en kies hoe het verschil
                verrekend wordt.</p>

            <div style="background:#2c2c2e; padding:15px; border-radius:10px; margin-bottom:20px;">
                <div style="font-size:12px; color:#888;">Nieuwe Tijd</div>
                <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
                    <button class="modal-btn" style="width:40px; height:40px; padding:0; background:#444;"
                        onclick="adjustLiveRestInput(-5)">-5</button>
                    <input type="number" id="live-rest-input" value="10"
                        style="font-size:32px; background:transparent; border:none; color:white; font-weight:bold; text-align:center; width:80px; font-family: 'Outfit', sans-serif;"
                        onchange="calcLiveRestDiff()">
                    <button class="modal-btn" style="width:40px; height:40px; padding:0; background:#444;"
                        onclick="adjustLiveRestInput(5)">+5</button>
                </div>
                <div id="live-rest-diff" style="margin-top:5px; font-weight:bold; color:#0A84FF;">+0s per keer</div>
            </div>

            <button class="modal-btn" id="btn-rest-push" style="background: #0A84FF; color: white;"
                onclick="applyLiveRestAdjustment('push')">
                🗓️ Verzet Eindtijd
                <span class="btn-subtext" id="sub-rest-push">Eindtijd schuift op met Xm</span>
            </button>

            <button class="modal-btn" id="btn-rest-work" style="background: #FF9F0A; color: black;"
                onclick="applyLiveRestAdjustment('work')">
                💪 Compenseer met Werk
                <span class="btn-subtext" id="sub-rest-work">Werk wordt X seconden</span>
            </button>

            <button class="modal-btn" style="background: #333; color: #888; margin-top:15px; border:1px solid #444;"
                onclick="cancelLiveRestAdjustment()">
                ❌ Annuleren
            </button>
        </div>
    </div>

    <div id="schedule-modal">
        <div class="modal-content">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h3 style="margin:0;">Volledig Schema</h3>
                <span style="font-size:24px; cursor:pointer;" onclick="closeScheduleModal()">×</span>
            </div>
            <div style="font-size:12px; color:#888; margin-bottom:5px;">Klik op een naam om deze te wijzigen.</div>
            <div class="schedule-table-container">
                <table class="schedule-table" id="full-schedule-table">
                    <thead>
                        <tr>
                            <th style="width:50px;">Tijd</th>
                            <th>Oefening / Fase</th>
                            <th style="width:40px;">Sec</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <button class="modal-btn"
                style="background: #BF5AF2; color: white; margin-top:15px; width:100%; font-weight:bold;"
                onclick="openGeneratorModal(); closeScheduleModal();">🤖 AI TRAINING GENERATOR</button>
            <div style="display:flex; gap:10px; margin-top:10px;">
                <button class="modal-btn" style="flex:1; background: #333; color: white; margin-top:0;"
                    onclick="closeScheduleModal()">Sluiten</button>
                <button class="modal-btn" style="flex:1; background: #0A84FF; color: white; margin-top:0;"
                    onclick="shareSchedulePDF()">Delen (PDF)</button>
            </div>
        </div>
    </div>

    <div id="exercise-selector-modal" class="modal-overlay"
        style="display:none; align-items:center; justify-content:center;">
        <div class="modal-content"
            style="max-width:400px; padding:0; overflow:hidden; display:flex; flex-direction:column; height:80vh; max-height:600px; width:95%;">

            <!-- Header -->
            <div
                style="padding:15px; background:#1c1c1e; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center; flex-shrink:0;">
                <h3 id="ex-modal-title" style="margin:0; font-size:16px; color:white;">Kies Oefening</h3>
                <div style="font-size:24px; cursor:pointer; padding:5px;" onclick="closeExerciseSelector()">×</div>
            </div>

            <!-- Hidden Inputs (Needed for Logic) -->
            <input type="hidden" id="edit-round-idx">
            <input type="hidden" id="edit-ex-idx">
            <input type="hidden" id="edit-set-idx">
            <input type="hidden" id="edit-new-val">

            <!-- List View -->
            <div id="ex-list-view" style="flex:1; display:flex; flex-direction:column; overflow:hidden;">

                <!-- Filters -->
                <div
                    style="padding:10px 10px 0 10px; background:#000; flex-shrink:0; display:flex; flex-direction:column; gap:10px;">
                    <select id="filter-category"
                        style="width:100%; padding:8px; border-radius:6px; background:#333; color:white; border:none; font-size:14px;"
                        onchange="filterExercises()">
                        <option value="">Alle Categorieën</option>
                    </select>
                    <select id="filter-material"
                        style="width:100%; padding:8px; border-radius:6px; background:#333; color:white; border:none; font-size:14px;"
                        onchange="filterExercises()">
                        <option value="">Alle Materialen</option>
                    </select>
                </div>

                <div style="padding:10px; background:#000; flex-shrink:0;">
                    <input type="text" id="ex-search-input" placeholder="Zoek oefening..."
                        style="width:100%; padding:12px; border-radius:8px; border:none; background:#333; color:white; font-size:16px;"
                        onkeyup="filterExercises()">
                </div>
                <ul id="ex-list-ul"
                    style="list-style:none; padding:0; margin:0; overflow-y:auto; flex:1; -webkit-overflow-scrolling: touch;">
                    <!-- JS Populated -->
                </ul>
            </div>

            <!-- Validation Modal -->
            <div id="validation-modal" class="modal" style="display:none;">
                <div class="modal-content">
                    <h3>Audio Bestanden Controleren</h3>
                    <p id="validation-status">Bezig met controleren...</p>
                    <ul id="validation-list"
                        style="text-align:left; font-size:12px; color:#ff453a; max-height:200px; overflow-y:auto; margin:10px 0;">
                    </ul>
                    <div class="modal-buttons">
                        <button class="btn-primary"
                            onclick="document.getElementById('validation-modal').style.display='none'">OK</button>
                    </div>
                </div>
            </div>

            <!-- Setup Screen -->
            <!-- Detail View -->
            <div id="ex-detail-view"
                style="display:none; flex:1; flex-direction:column; padding:20px; overflow-y:auto; background:#111;">
                <h2 id="detail-tit" style="margin-top:0; color:white;">Oefening</h2>
                <span id="detail-meta"
                    style="color:#30D158; font-size:14px; margin-bottom:10px; display:inline-block; border:1px solid #30D158; padding:2px 6px; border-radius:4px;">Type</span>

                <div style="background:#222; padding:15px; border-radius:8px; margin: 15px 0;">
                    <p id="detail-desc" style="color:#ccc; font-size:14px; line-height:1.4; margin:0;">Instructies...
                    </p>
                </div>

                <a id="detail-vid-btn" href="#" target="_blank" class="modal-btn"
                    style="background:#5856D6; color:white; text-decoration:none; display:flex; justify-content:center; align-items:center; margin-bottom:20px; flex-shrink:0;">
                    📺 Bekijk Video
                </a>



                <div style="background:#222; padding:15px; border-radius:8px; margin-bottom:20px; flex-shrink:0;">
                    <div style="font-size:12px; color:#888; margin-bottom:10px; text-transform:uppercase;">Wijziging
                        toepassen op:</div>

                    <label style="display:flex; align-items:center; margin-bottom:15px; cursor:pointer;">
                        <input type="radio" name="scope_sel" value="all_rounds" checked
                            style="margin-right:15px; transform:scale(1.2);">
                        <div>
                            <div style="font-weight:bold; color:white;">Totaal (Alle Rondes)</div>
                            <div style="font-size:11px; color:#aaa;">Vervang deze oefening in het hele schema</div>
                        </div>
                    </label>

                    <label style="display:flex; align-items:center; margin-bottom:15px; cursor:pointer;">
                        <input type="radio" name="scope_sel" value="set_all_rounds"
                            style="margin-right:15px; transform:scale(1.2);">
                        <div>
                            <div style="font-weight:bold; color:white;">Alleen Set <span id="scope-set-force">1</span>
                                (Alle Rondes)</div>
                            <div style="font-size:11px; color:#aaa;">Bijv. alleen de 1e set van elke ronde</div>
                        </div>
                    </label>

                    <label style="display:flex; align-items:center; cursor:pointer;">
                        <input type="radio" name="scope_sel" value="single"
                            style="margin-right:15px; transform:scale(1.2);">
                        <div>
                            <div style="font-weight:bold; color:white;">Alleen DIT blokje</div>
                            <div style="font-size:11px; color:#aaa;">Eenmalige wijziging voor dit moment</div>
                        </div>
                    </label>
                </div>

                <div style="display:flex; gap:10px; margin-top:auto;">
                    <button class="modal-btn" style="background:#333; flex:1;" onclick="backToExList()">Terug</button>
                    <button class="modal-btn" style="background:#30D158; color:black; flex:1;"
                        onclick="confirmExerciseSelection()">Bevestigen</button>
                </div>
            </div>

        </div>
    </div>


    <!-- Audio Debug Log -->


    <input type="time" id="hidden-endtime-input" onchange="handleNewEndTime(this.value)" style="display:none;">

    <div id="generator-modal" class="modal-overlay" style="display:none; align-items:center; justify-content:center;">
        <div class="modal-content">
            <div
                style="padding:15px; background:#1c1c1e; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center;">
                <h3 style="margin:0; font-size:16px; color:white;">⚡ AI Generator</h3>
                <div style="font-size:24px; cursor:pointer;" onclick="closeGeneratorModal()">×</div>
            </div>

            <div style="flex:1; overflow-y:auto;">
                <!-- MATERIALEN -->
                <div class="gen-section">
                    <div class="gen-section-title"
                        style="display:flex; justify-content:space-between; align-items:center;">
                        <span>1. Kies Materialen (Volgorde van boven naar beneden)</span>
                        <div style="display:flex; gap:5px;">
                            <button class="btn-micro" onclick="toggleGenCheckboxes('gen_mat', true)">Alles</button>
                            <button class="btn-micro" onclick="toggleGenCheckboxes('gen_mat', false)">Niets</button>
                        </div>
                    </div>
                    <div style="font-size:11px; color:#666; margin-bottom:5px;">De app rouleert door geselecteerde
                        materialen.</div>
                    <div class="gen-checkbox-grid" id="gen-materials-list">
                        <!-- JS Insert -->
                    </div>
                </div>

                <!-- CATEGORIEEN -->
                <div class="gen-section">
                    <div class="gen-section-title"
                        style="display:flex; justify-content:space-between; align-items:center;">
                        <span>2. Kies Spiergroepen</span>
                        <div style="display:flex; gap:5px;">
                            <button class="btn-micro" onclick="toggleGenCheckboxes('gen_cat', true)">Alles</button>
                            <button class="btn-micro" onclick="toggleGenCheckboxes('gen_cat', false)">Niets</button>
                        </div>
                    </div>
                    <div class="gen-checkbox-grid" id="gen-categories-list">
                        <!-- JS Insert -->
                    </div>
                </div>

                <!-- LOGICA SETS -->
                <div class="gen-section">
                    <div class="gen-section-title">3. Herhaling per Set (Binnen 1 ronde)</div>
                    <div class="gen-radio-group">
                        <div class="gen-radio-opt active" onclick="setGenLogic('set', 'same', this)">Zelfde Oefening
                            (1.1 = 1.2)</div>
                        <div class="gen-radio-opt" onclick="setGenLogic('set', 'diff', this)">Elke Set Anders</div>
                    </div>
                </div>

                <!-- LOGICA RONDES -->
                <div class="gen-section">
                    <div class="gen-section-title">4. Herhaling per Ronde</div>
                    <div class="gen-radio-group">
                        <div class="gen-radio-opt active" onclick="setGenLogic('round', 'same', this)">Zelfde als Ronde
                            1</div>
                        <div class="gen-radio-opt" onclick="setGenLogic('round', 'diff', this)">Elke Ronde Anders
                        </div>
                    </div>
                </div>
            </div>

            <button class="gen-btn-generate" onclick="runGenerator()">✨ Genereer Training</button>
        </div>
    </div>

    <script>
        // --- v1.16: SIMPLIFIED AUDIO (MP3 ONLY) ---
        // --- VARIABELEN ---
        let audioMode = 'speech';
        let speechPlaylists = {};
        let editingSpeechKey = null;
        let customNames = {};
        let failedAudioKeys = new Set(); // Cache for missing MP3s

        // CONTAINERS
        // HARDE FALLBACK DEFAULTS (Zodat de app altijd werkt)
        const appDefaults = {
            rounds: 2, exercises: 6, sets: 2,
            restSec: 20, exerciseRestSec: 30, roundRestSec: 90,
            totalMin: 30,
            coachPreset: 'tabataman', // Default to MP3
            bonuses: [
                { name: "Bonus 1", duration: 0, freq: "start_round" },
                { name: "Bonus 2", duration: 0, freq: "start_round" },
                { name: "Bonus 3", duration: 0, freq: "start_round" }
            ]
        };

        const coachPresets = {
            'tabataman': {
                use_mp3: true,
                variants: {
                    'prep_countdown': 1, // Only 1 found
                    'finish': 1,
                    'mile_end': 1, 'mile_half': 1, 'mile_lastround': 1, 'mile_start': 1,
                    'prep_intro': 1,
                    'rest_round_15s': 1, 'rest_round_start': 1,
                    'rest_set_start': 1, 'rest_set_tips': 1,
                    'rest_switch_10s': 1, 'rest_switch_start': 1,
                    'work_start': 4, // Found 4 variants!
                    'work_halfway': 1,
                    'work_30s': 1, 'work_10s': 1
                }
            },
            'eva': {
                use_mp3: true,
                variants: {
                    'prep_countdown': 1,
                    'finish': 1,
                    'mile_end': 1, 'mile_half': 1, 'mile_start': 1,
                    'prep_intro': 1,
                    'rest_round_15s': 1, 'rest_round_start': 1,
                    'rest_set_start': 1, 'rest_set_tips': 1,
                    'rest_switch_10s': 1, 'rest_switch_start': 1,
                    'work_start': 4,
                    'work_halfway': 1,
                    'work_30s': 1, 'work_10s': 1
                }
            }
        };


        let currentCoachName = "Tabataman (Standaard)";

        let speechSettings = {}; // This will now only hold the current coach's settings (use_mp3: true)

        // UI Config (still used for validation and structure, but not for TTS text)
        const uiConfig = [
            { header: "Voorbereiding" },
            { id: "prep_intro", label: "Introductie tekst", type: "text" },
            { id: "prep_countdown", label: "Aftellen (3, 2, 1)", type: "bool" },
            { header: "Tijdens Oefening (Werken)" },
            { id: "work_start", label: "Start commando", type: "text" },
            { id: "work_halfway", label: "Melding halverwege", type: "text" },
            { id: "work_30s", label: "Nog 30 seconden", type: "text" },
            { id: "work_10s", label: "Nog 10 seconden", type: "text" },

            { header: "Tijdens Rust (Set)" },
            { id: "rest_set_start", label: "Rust commando", type: "text" },
            { id: "rest_set_tips", label: "Willekeurige tips (ademhaling/drinken)", type: "bool" },
            { header: "Tijdens Rust (Wissel)" },
            { id: "rest_switch_start", label: "Wissel commando", type: "text" },
            { id: "rest_switch_info", label: "Noem volgende oefening nummer", type: "bool" },
            { id: "rest_switch_10s", label: "Waarschuwing 10s voor einde", type: "text" },
            { header: "Tijdens Rust (Ronde)" },
            { id: "rest_round_start", label: "Grote pauze commando", type: "text" },
            { id: "rest_round_info", label: "Noem volgende ronde nummer", type: "bool" },
            { id: "rest_round_15s", label: "Waarschuwing 15s voor einde", type: "text" },
            { header: "Mijlpalen & Einde" },
            { id: "mile_start", label: "25% (Goede start)", type: "text" },
            { id: "mile_half", label: "50% (Helft)", type: "text" },
            { id: "mile_end", label: "75% (Eindsprint)", type: "text" },
            { id: "work_start_lastround", label: "Start laatste oefening", type: "text" },
            { id: "finish", label: "Einde training", type: "text" }
        ];

        // GLOBAL STATE
        // AUDIO_VARIANTS moved to coachPresets
        let audioPlaylists = {}; // Stores the shuffled queue per key: { 'prep_countdown': [2, 4, 1, 3] }

        let WORKOUT_DB = []; // Will be loaded from JSON
        let schedule = [];
        let milestonesTriggered = { m25: false, m50: false, m75: false };
        let workTimeSec = 0, restTimeSec = 0, exerciseRestSec = 0, roundRestSec = 0;
        let currentIndex = 0;
        let timerInterval;
        let isPaused = false;
        window.lastStepChangeTime = 0; // SAFETY: Initialize global anchor

        // Load Database
        // Cache-busting: append timestamp
        fetch('workoutdatabase.json?v=' + new Date().getTime())
            .then(response => response.json())
            .then(data => {
                WORKOUT_DB = data;
                console.log("Workout Database Loaded:", WORKOUT_DB.length, "items");
            })
            .catch(err => console.error("Failed to load workout database:", err));
        let pauseStartTime = 0;
        let workoutStartTime, targetEndTimeDate;
        let totalWorkSetsGlobal = 0;
        let audioCtx;
        let currentPauseDuration = 0;

        // HELPER: Get Bonus Data
        function getBonusData(i) {
            return {
                name: document.getElementById(`bonus${i}-name`).value || `Bonus ${i}`,
                min: parseInt(document.getElementById(`bonus${i}-duration`).value) || 0,
                freq: document.getElementById(`bonus${i}-freq`).value,
                id: i
            };
        }

        // HELPER: Detect iOS
        function isIOS() {
            return (
                /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                (navigator.userAgent.includes("Mac") && "ontouchend" in document)
            );
        }

        if (isIOS()) {
            console.log("Dit is een iOS apparaat (iPhone of iPad)");
        }

        // --- ROBUUSTE FUNCTIE OM DATA TE LADEN ---
        // --- ROBUUSTE FUNCTIE OM DATA TE LADEN ---
        async function initApp() {
            const select = document.getElementById('coach-preset-live'); // UPDATED: Target Live Select
            if (select) {
                select.innerHTML = '<option value="loading" disabled selected>Laden...</option>';

                const addOption = (id, name) => {
                    if (!select.querySelector(`option[value="${id}"]`)) {
                        const opt = document.createElement('option');
                        opt.value = id; opt.text = name;
                        select.appendChild(opt);
                    }
                };

                // 1. Init Defaults (Skipped external fetch, usage hardcoded)

                // 2. Probeer Coaches
                for (const coachId in coachPresets) {
                    let displayName = coachId.charAt(0).toUpperCase() + coachId.slice(1);
                    if (coachId === 'tabataman') displayName = 'TabataMan (Actief)';
                    if (coachId === 'eva') displayName = 'Eva (Nederlands Energiek)';
                    // Generic fallback name fix
                    if (coachId === 'default') displayName = "Standaard (Tabataman)";
                    if (coachId === 'drill_sergeant') displayName = "Drill Sergeant (Intens)";
                    if (coachId === 'zen_master') displayName = "Zen Master (Rust)";

                    addOption(coachId, displayName);
                }

                // Clean up dropdown UI
                const loadingOpt = select.querySelector('option[value="loading"]');
                if (loadingOpt) loadingOpt.remove();
            }

            // 3. PAS NU DE WAARDEN TOE
            finalizeInit();
        }

        function updateBonusVisibility() {
            const b1 = parseInt(document.getElementById('bonus1-duration').value || 0);
            const b2 = parseInt(document.getElementById('bonus2-duration').value || 0);
            const b3 = parseInt(document.getElementById('bonus3-duration').value || 0);

            const r2 = document.getElementById('bonus-row-2');
            const r3 = document.getElementById('bonus-row-3');

            // Logic: Stickiness.
            // Row 2 Visible if: B1 set OR B2 set OR B3 set
            if (b1 > 0 || b2 > 0 || b3 > 0) {
                r2.style.display = 'flex';
            } else {
                r2.style.display = 'none';
            }

            // Row 3 Visible if: B2 set OR B3 set (B3 needs B2 parent context)
            if (b2 > 0 || b3 > 0) {
                r3.style.display = 'flex';
            } else {
                r3.style.display = 'none';
            }
        }

        function finalizeInit() {
            const select = document.getElementById('coach-preset-live'); // UPDATED

            // Selecteer standaard uit defaults, of fallback op eerste in lijst
            let targetPreset = appDefaults.coachPreset || 'tabataman';

            // If the target preset doesn't exist (shouldn't happen with hardcoded presets),
            // or if the select value isn't set, default to 'tabataman'.
            if (select && (!coachPresets[targetPreset] || !select.querySelector(`option[value="${targetPreset}"]`))) {
                targetPreset = 'tabataman';
            }

            if (select) select.value = targetPreset;
            if (!speechSettings || Object.keys(speechSettings).length === 0) {
                speechSettings = JSON.parse(JSON.stringify(coachPresets[targetPreset]));
            }

            loadFromLocal();
            checkForSharedSettings();

            // Generate Toggles
            renderAudioToggles();

            // Zet inputs op basis van defaults (als ze nog niet zijn overschreven door local)
            // Let op: loadFromLocal overschrijft dit weer als er iets is opgeslagen.
            // Als er NIETS is opgeslagen, willen we de defaults in de UI zien:
            if (!localStorage.getItem('fnh_settings_v8')) {
                applyDefaultsToUI();
            }

            // Sync tijd en calculatie
            if (!document.getElementById('endTimeValue').value) {
                syncTime('duration');
            }
            calculateRealTime();
            updateBonusVisibility();

            // Show mix mode on iOS
            if (isIOS()) {
                const mixC = document.getElementById('ios-mix-container');
                if (mixC) mixC.style.display = 'block';
            }
        }

        function applyDefaultsToUI() {
            document.getElementById('rounds').value = appDefaults.rounds;
            document.getElementById('exercises').value = appDefaults.exercises;
            document.getElementById('sets').value = appDefaults.sets;
            document.getElementById('restSec').value = appDefaults.restSec;
            document.getElementById('exerciseRestSec').value = appDefaults.exerciseRestSec;
            document.getElementById('roundRestSec').value = appDefaults.roundRestSec;
            document.getElementById('totalMin').value = appDefaults.totalMin;
            const coachSel = document.getElementById('coach-preset-live'); // UPDATED
            if (coachSel) coachSel.value = appDefaults.coachPreset;

            if (appDefaults.bonuses) {
                for (let i = 0; i < 3; i++) {
                    if (appDefaults.bonuses[i]) {
                        document.getElementById(`bonus${i + 1}-name`).value = appDefaults.bonuses[i].name;
                        document.getElementById(`bonus${i + 1}-duration`).value = appDefaults.bonuses[i].duration;
                        document.getElementById(`bonus${i + 1}-freq`).value = appDefaults.bonuses[i].freq;
                    }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            populateDropdowns();

            // Start async init, maar blokkeer de UI niet
            initApp();

            document.querySelectorAll('input.param-input').forEach(i => {
                i.addEventListener('input', () => { calculateRealTime(); saveToLocal(); });
            });

            // These are now handled by the new card-group
            // document.getElementById('btn-audio-speech').onclick = () => { setAudioMode('speech'); saveToLocal(); };
            // document.getElementById('btn-audio-beep').onclick = () => { setAudioMode('beep'); saveToLocal(); };

            document.addEventListener("visibilitychange", handleVisibilityChange);
            window.applyFNHPreset = function () {
                if (!confirm("FNH Preset laden? (45m, 2 rondes, 8 oefeningen)")) return;

                document.getElementById('rounds').value = 2;
                document.getElementById('exercises').value = 8;
                document.getElementById('sets').value = 2;

                document.getElementById('restSec').value = 15;
                document.getElementById('exerciseRestSec').value = 30; // Wissel
                document.getElementById('roundRestSec').value = 90;

                document.getElementById('totalMin').value = 45;
                document.getElementById('startTimeValue').value = "19:45";

                // Coach Tabataman
                const coachSel = document.getElementById('coach-preset-live'); // UPDATED
                if (coachSel && coachSel.querySelector('option[value="tabataman"]')) {
                    coachSel.value = 'tabataman';
                }

                // Disable Bonuses
                for (let i = 1; i <= 3; i++) {
                    document.getElementById(`bonus${i}-duration`).value = 0;
                }

                // Enable Milestones (Requirements: Logo & Reset = ON)
                const mileKeys = ['mile_start', 'mile_half', 'mile_end'];
                mileKeys.forEach(k => {
                    if (!speechSettings[k]) speechSettings[k] = {};
                    speechSettings[k].enabled = true;
                });
                renderAudioToggles();
                syncTime('duration');
                calculateRealTime();
                saveToLocal();
            }

            // Initiele calculatie voor de zekerheid
            calculateRealTime();
        });

        function syncTime(source) {
            const min = parseInt(document.getElementById('totalMin').value) || 30;
            const startInput = document.getElementById('startTimeValue');
            const endInput = document.getElementById('endTimeValue');
            const now = new Date();

            const getDateFromTimeStr = (str, baseDate) => {
                if (!str) return null;
                const [h, m] = str.split(':');
                let d = new Date(baseDate.getTime());
                d.setHours(h, m, 0, 0);
                return d;
            };

            if (source === 'duration') {
                // Change Duration -> Update End Time
                let base = getDateFromTimeStr(startInput.value, now) || now;
                let target = new Date(base.getTime() + min * 60000);
                endInput.value = target.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', hour12: false });
            }
            else if (source === 'starttime') {
                // Change Start Time -> Update Duration (Keep End Time fixed)
                let start = getDateFromTimeStr(startInput.value, now) || now;
                let end = getDateFromTimeStr(endInput.value, now);

                if (end) {
                    if (end < start) end.setDate(end.getDate() + 1);
                    let diffMs = end - start;
                    let diffMin = Math.round(diffMs / 60000);
                    if (diffMin < 0) diffMin += 1440;

                    const sel = document.getElementById('totalMin');
                    let exists = false;
                    for (let i = 0; i < sel.options.length; i++) { if (parseInt(sel.options[i].value) === diffMin) exists = true; }

                    if (!exists && diffMin > 0) {
                        const opt = document.createElement('option');
                        opt.value = diffMin;
                        opt.text = diffMin + "m";
                        sel.add(opt, 0);
                        sel.value = diffMin;
                    } else if (diffMin > 0) {
                        sel.value = diffMin;
                    }
                } else {
                    // No End Time set -> Standard behavior (maintain duration)
                    let target = new Date(start.getTime() + min * 60000);
                    endInput.value = target.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', hour12: false });
                }
            }
            else if (source === 'endtime') {
                // Change End Time -> Update Duration
                let end = getDateFromTimeStr(endInput.value, now);
                if (!end) return;

                let base = getDateFromTimeStr(startInput.value, now) || now;

                // Handle overnight
                if (end < base) end.setDate(end.getDate() + 1);

                let diffMs = end - base;
                let diffMin = Math.round(diffMs / 60000);

                const sel = document.getElementById('totalMin');
                let exists = false;
                for (let i = 0; i < sel.options.length; i++) { if (parseInt(sel.options[i].value) === diffMin) exists = true; }

                if (!exists && diffMin > 0) {
                    const opt = document.createElement('option');
                    opt.value = diffMin;
                    opt.text = diffMin + "m";
                    sel.add(opt, 0);
                    sel.value = diffMin;
                } else if (diffMin > 0) {
                    sel.value = diffMin;
                }
            }
            calculateRealTime();
        }

        function populateDropdowns() {
            const fill = (id, start, end, step = 1, suffix = "") => {
                const sel = document.getElementById(id);
                const resumeSel = document.getElementById("start-" + (id === 'rounds' ? 'round' : (id === 'exercises' ? 'ex' : (id === 'sets' ? 'set' : ''))));
                if (sel) sel.innerHTML = "";
                if (resumeSel) resumeSel.innerHTML = "";
                for (let i = start; i <= end; i += step) {
                    const opt = document.createElement('option'); opt.value = i; opt.text = i + suffix; if (sel) sel.appendChild(opt);
                    if (resumeSel) { const opt2 = document.createElement('option'); opt2.value = i; opt2.text = i + suffix; resumeSel.appendChild(opt2); }
                }
            };
            fill('rounds', 1, 10);
            fill('exercises', 1, 20);
            fill('sets', 1, 10);

            const fillTotal = (id) => {
                const sel = document.getElementById(id); sel.innerHTML = "";
                for (let i = 1; i <= 10; i++) { const opt = document.createElement('option'); opt.value = i; opt.text = i + "m"; sel.appendChild(opt); }
                for (let i = 15; i <= 120; i += 5) { const opt = document.createElement('option'); opt.value = i; opt.text = i + "m"; sel.appendChild(opt); }
            };
            fillTotal('totalMin');

            const fillRest = (id) => {
                const sel = document.getElementById(id); sel.innerHTML = "";
                for (let i = 5; i <= 60; i += 5) { const opt = document.createElement('option'); opt.value = i; opt.text = i + "s"; sel.appendChild(opt); }
                for (let i = 70; i <= 180; i += 10) { const opt = document.createElement('option'); opt.value = i; opt.text = i + "s"; sel.appendChild(opt); }
                for (let i = 210; i <= 300; i += 30) { const opt = document.createElement('option'); opt.value = i; opt.text = i + "s"; sel.appendChild(opt); }
            };
            fillRest('restSec'); fillRest('exerciseRestSec'); fillRest('roundRestSec');

            // Fill Bonus Duration Dropdown
            const fillBonusDuration = (id) => {
                const sel = document.getElementById(id); sel.innerHTML = "";
                const opt0 = document.createElement('option'); opt0.value = 0; opt0.text = "Uit"; sel.appendChild(opt0);
                for (let i = 1; i <= 15; i++) { const opt = document.createElement('option'); opt.value = i; opt.text = i + " min"; sel.appendChild(opt); }
            };

            const fillBonusFreq = (id) => {
                const sel = document.getElementById(id); sel.innerHTML = "";

                const addOpt = (val, txt) => {
                    const opt = document.createElement('option'); opt.value = val; opt.text = txt; sel.appendChild(opt);
                };

                addOpt('start_round', 'Begin elke ronde');
                addOpt('warmup', 'Alleen begin (Warming-up)');
                addOpt('end_round', 'Eind elke ronde');
                addOpt('end_session', 'Einde van de les (Toetje)');

                const grp = document.createElement('optgroup'); grp.label = "── INTERVALLEN ──"; sel.appendChild(grp);

                for (let i = 1; i <= 12; i++) {
                    const opt = document.createElement('option'); opt.value = i; opt.text = `Om de ${i} oefeningen`; sel.appendChild(opt);
                }
            };

            // Loop for 3 bonuses
            for (let i = 1; i <= 3; i++) {
                fillBonusDuration(`bonus${i}-duration`);
                fillBonusFreq(`bonus${i}-freq`);
            }
        }

        function handleVisibilityChange() {
            if (document.visibilityState === 'visible' && !isPaused && timerInterval) {
                // Interval logic handles catch up automatically
            }
        }

        function toggleSection(id) {
            const el = document.getElementById(id);
            const header = el.previousElementSibling;
            if (el.style.display === 'none' || el.classList.contains('hidden')) {
                el.style.display = 'block';
                el.classList.remove('hidden');
                header.classList.add('open');
            } else {
                el.style.display = 'none';
                el.classList.add('hidden');
                header.classList.remove('open');
            }
        }

        function applyCoachPreset(presetId) {
            const preset = coachPresets[presetId];
            if (!preset) return;
            speechSettings = JSON.parse(JSON.stringify(preset));
            renderAudioToggles();
            validateCoachFiles(presetId);
        }

        function handleCoachChange() {
            const val = document.getElementById('coach-preset-live').value; // UPDATED
            // Merge new coach preset but KEEP user toggle overrides if they exist? 
            // Ideally we reset to the new coach defaults, but user might want to keep "Halfway OFF".
            // For now, let's reset to defaults of the new coach to be safe.
            speechSettings = JSON.parse(JSON.stringify(coachPresets[val]));

            saveToLocal();
            renderAudioToggles(); // Re-render toggles
            validateCoachFiles(val);
        }

        // --- v1.16: RENDER AUDIO TOGGLES ---
        function renderAudioToggles() {
            const container = document.getElementById('audio-toggles-panel');
            if (!container) return;
            container.innerHTML = "";

            if (audioMode === 'beep') {
                container.innerHTML = "<div style='color:#666; font-style:italic; font-size:12px; padding:10px;'>In piepjes-modus zijn er geen spraak instellingen.</div>";
                return;
            }

            uiConfig.forEach(item => {
                if (item.header) {
                    const h = document.createElement('div'); h.className = "category-header"; h.innerText = item.header;
                    h.style.marginTop = "15px"; h.style.marginBottom = "5px"; h.style.fontSize = "11px"; h.style.color = "#888"; h.style.fontWeight = "600";
                    container.appendChild(h);
                } else {
                    const wrapper = document.createElement('div'); wrapper.className = "switch-row";

                    const label = document.createElement('span'); label.className = "switch-label"; label.innerText = item.label;
                    const switchLabel = document.createElement('label'); switchLabel.className = "switch";

                    const cb = document.createElement('input'); cb.type = "checkbox";

                    // Check logic: if key missing, assume enabled by default
                    let isEnabled = true;
                    if (speechSettings[item.id] && typeof speechSettings[item.id].enabled !== 'undefined') {
                        isEnabled = speechSettings[item.id].enabled;
                    }
                    cb.checked = isEnabled;

                    cb.onchange = () => {
                        if (!speechSettings[item.id]) speechSettings[item.id] = { enabled: true };
                        speechSettings[item.id].enabled = cb.checked;
                        saveToLocal();
                    };

                    const slider = document.createElement('span'); slider.className = "slider";
                    switchLabel.appendChild(cb); switchLabel.appendChild(slider);
                    wrapper.appendChild(label); wrapper.appendChild(switchLabel);
                    container.appendChild(wrapper);
                }
            });
        }

        async function validateCoachFiles(coachId) {
            const modal = document.getElementById('validation-modal');
            const status = document.getElementById('validation-status');
            const list = document.getElementById('validation-list');

            modal.style.display = 'flex';
            status.innerText = "Controleren op MP3 bestanden...";
            status.style.color = "#fff";
            list.innerHTML = "";

            const expectedKeys = [];
            uiConfig.forEach(item => {
                if (item.id) expectedKeys.push(item.id);
            });

            // Add manual bonus keys if we want to be thorough, but uiConfig covers most speech triggers.

            const missing = [];

            // Check in chunks to not overload (optional, but Promise.all is usually fine for ~20 files)
            const preset = coachPresets[coachId];
            const variants = preset ? (preset.variants || {}) : {};

            console.log(`[Validation] Checking ${coachId}. Variants found: ${Object.keys(variants).length}`);

            const checks = expectedKeys.map(async (key) => {
                // EXCLUDE LOGIC-ONLY KEYS (No MP3s expected)
                if (['rest_switch_info', 'rest_round_info'].includes(key)) return null;

                try {
                    let filename = `${key}.mp3`;
                    // Check for variant suffix (default to _1 for validation)
                    // Ensure we check exactly what is in variants map
                    if (variants[key] && variants[key] >= 1) {
                        filename = `${key}_1.mp3`;
                    } else {
                        // Debug if we expected a variant but found none
                        if (['work_start', 'prep_countdown'].includes(key)) {
                            console.warn(`[Validation] Warning: No variants found for ${key} in ${coachId}, defaulting to base.mp3`);
                        }
                    }

                    const path = `coaches/${coachId}/${filename}`;
                    const resp = await fetch(path, { method: 'HEAD' });
                    if (!resp.ok) return key + ` (${filename})`; // Return details
                    return null;
                } catch (e) {
                    return key; // Error means missing or network issue
                }
            });

            const results = await Promise.all(checks);
            results.forEach(res => {
                if (res) missing.push(res);
            });

            if (missing.length > 0) {
                status.innerText = `Er ontbreken ${missing.length} bestanden:`;
                status.style.color = "#ff453a";
                missing.forEach(key => {
                    const li = document.createElement('li');
                    li.innerText = `${key}.mp3`;
                    list.appendChild(li);
                });
            } else {
                status.innerText = "Alle audio bestanden zijn aanwezig! ✅";
                status.style.color = "#30D158";
                setTimeout(() => {
                    if (modal.style.display === 'flex') modal.style.display = 'none';
                }, 1500);
            }
        }


        // --- SCHEDULE MODAL LOGIC ---
        function getExerciseDetails(name) {
            if (typeof WORKOUT_DB === 'undefined') return null;
            // Try exact match first
            let match = WORKOUT_DB.find(i => i.exercise_name === name);
            if (match) return match;
            // Try case-insensitive
            return WORKOUT_DB.find(i => i.exercise_name.toLowerCase() === name.toLowerCase());
        }

        function showScheduleModal() {
            generateScheduleData(false);
            const tableBody = document.querySelector('#full-schedule-table tbody');
            tableBody.innerHTML = "";

            let currentTime = new Date();
            const startStr = document.getElementById('startTimeValue').value;
            if (startStr) {
                const [h, m] = startStr.split(':');
                currentTime.setHours(h, m, 0, 0);
                // If implied start is in the past (e.g. 09:00 while it's 20:00), 
                // typically for a schedule PREVIEW we just want to see that time on *today*.
                // So we don't necessarily need to shift to tomorrow unless logic dictates.
                // For a "What if" schedule, today's date with that time is sufficient context.
            }

            schedule.forEach((step) => {
                if (step.type === 'finish') return;

                const tr = document.createElement('tr');

                // Time Cell
                const tdTime = document.createElement('td');
                tdTime.style.verticalAlign = 'top';
                tdTime.style.paddingTop = '10px';
                tdTime.innerText = currentTime.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

                // Content Cell
                const tdContent = document.createElement('td');

                // --- RICH CARD LOGIC ---
                if (step.type === 'work' && step.info.exercise > 0) {
                    const exName = step.label;
                    const details = getExerciseDetails(exName);

                    const divCard = document.createElement('div');
                    divCard.className = 'schedule-card';

                    // Video Button
                    let videoBtnHtml = '';
                    let matName = '-';
                    let matDesc = '-';
                    let instr = '-';

                    if (details) {
                        matName = details.material_name || '-';
                        matDesc = details.material_description || '-';
                        instr = details.instructions || '-';

                        let videoLink = "";
                        if (details.video_search_url) {
                            videoLink = details.video_search_url;
                        } else {
                            videoLink = `https://www.youtube.com/results?search_query=${encodeURIComponent(step.label + " shorts")}`;
                        }

                        // Buttons HTML
                        videoBtnHtml = `
                        <div style="margin-top:5px; display:flex; gap:5px;">
                             <a href="${videoLink}" target="_blank" class="modal-btn" style="padding:5px 10px; font-size:11px; background:#eee; color:black; margin:0; flex:1; display:flex; justify-content:center; align-items:center;">▶ Video</a>
                        </div>`;
                    }

                    // New Labeled Structure
                    divCard.innerHTML = `
                        <div style="display:flex; flex-direction:column; gap:10px; text-align:left;">
                            
                            <div>
                                <div style="font-size:10px; font-weight:bold; color:#888; text-transform:uppercase; margin-bottom:2px;">Naam Oefening</div>
                                <div class="schedule-name" onclick="openExerciseSelector(${step.info.round}, ${step.info.exercise}, ${step.info.set}, '${exName}')" 
                                     style="cursor:pointer; text-decoration:underline; font-size:14px; font-weight:bold; color:#fff;">
                                    ${exName}
                                </div>
                            </div>

                            <div>
                                <div style="font-size:10px; font-weight:bold; color:#888; text-transform:uppercase; margin-bottom:2px;">Materiaal</div>
                                <div style="font-size:13px; color:#ddd;">
                                    ${matName} <span style="font-weight:normal; color:#bbb; font-style:italic;"> - ${matDesc}</span>
                                </div>
                            </div>

                            <div>
                                <div style="font-size:10px; font-weight:bold; color:#888; text-transform:uppercase;">Instructie</div>
                                <div style="font-size:13px; color:#fff; line-height:1.4;">${instr}</div>
                            </div>

                            <div style="margin-top:5px;">
                                ${videoBtnHtml}
                            </div>
                        </div>
                    `;
                    tdContent.appendChild(divCard);

                } else {
                    // Rest / Transition / Prep
                    // Keep it simple but styled slightly to match width
                    const divSimple = document.createElement('div');
                    divSimple.style.padding = '10px';
                    divSimple.style.color = '#888';
                    divSimple.innerText = step.label;
                    if (step.info && step.info.round && step.info.exercise > 0) {
                        divSimple.innerText += ` (R${step.info.round}/E${step.info.exercise})`;
                    }
                    tdContent.appendChild(divSimple);
                }

                // Duration Cell
                const tdDur = document.createElement('td');
                tdDur.style.verticalAlign = 'top';
                tdDur.style.paddingTop = '10px';
                tdDur.innerText = step.time;

                tr.appendChild(tdTime);
                tr.appendChild(tdContent);
                tr.appendChild(tdDur);
                tableBody.appendChild(tr);

                currentTime.setSeconds(currentTime.getSeconds() + step.time);
            });

            document.getElementById('schedule-modal').style.display = 'flex';
        }

        function closeScheduleModal() {
            document.getElementById('schedule-modal').style.display = 'none';
            calculateRealTime();
        }



        // --- NEW EXERCISE SELECTOR LOGIC ---
        let currentExContext = null; // {r, e, s}
        let selectedDbItem = null;

        function openExerciseSelector(r, e, s, currentName) {
            currentExContext = { r, e, s };
            document.getElementById('exercise-selector-modal').style.display = 'flex';
            document.getElementById('scope-set-force').innerText = s;

            // Generate list
            const ul = document.getElementById('ex-list-ul');
            ul.innerHTML = "";

            // Filters Sets
            const categories = new Set();
            const materials = new Map(); // Name -> Description

            // Add "Custom" option at top
            const customLi = document.createElement('li');
            customLi.className = "ex-list-item";
            customLi.style.borderBottom = "2px solid #333";
            customLi.innerHTML = `<span style="font-weight:bold; color:white;">✏️ Eigen Naam Invoeren...</span>`;
            customLi.onclick = () => {
                const name = prompt("Voer naam in:", currentName);
                if (name) {
                    selectedDbItem = { exercise_name: name }; // Pseudo item
                    showExDetail(selectedDbItem);
                }
            };
            ul.appendChild(customLi);

            // Populate from DB
            if (typeof WORKOUT_DB !== 'undefined') {
                WORKOUT_DB.forEach(item => {
                    const li = document.createElement('li');
                    li.className = "ex-list-item";

                    // Metadata for filtering
                    const cat = item.category || "Other";
                    const mat = item.material_name || "None";
                    const matDesc = item.material_description || "";

                    categories.add(cat);
                    if (!materials.has(mat)) {
                        materials.set(mat, matDesc);
                    }

                    li.dataset.search = (item.exercise_name + " " + cat + " " + item.id).toLowerCase();
                    li.dataset.cat = cat;
                    li.dataset.mat = mat;

                    li.innerHTML = `
                        <div style="font-weight:500; color:#eee;">${item.exercise_name}</div>
                        <div class="ex-cat-tag">${cat}</div>
                    `;
                    li.onclick = () => showExDetail(item);
                    ul.appendChild(li);
                });
            } else {
                ul.innerHTML += `<li class="ex-list-item">Database niet geladen.</li>`;
            }

            // Populate Filter Dropdowns
            const catSelect = document.getElementById('filter-category');
            catSelect.innerHTML = '<option value="">Alle Categorieën</option>';
            Array.from(categories).sort().forEach(c => {
                const opt = document.createElement('option');
                opt.value = c;
                opt.innerText = c;
                catSelect.appendChild(opt);
            });

            const matSelect = document.getElementById('filter-material');
            matSelect.innerHTML = '<option value="">Alle Materialen</option>';

            // Sort materials by Name
            const sortedMats = Array.from(materials.keys()).sort();

            sortedMats.forEach(m => {
                const desc = materials.get(m);
                const opt = document.createElement('option');
                opt.value = m;
                // Show "Name (Description)" or just "Name" if no desc
                // Shorten desc if too long? No, user asked for it. 
                // Maybe limit length for UI sanity.
                let displayText = m;
                if (desc && desc.length > 1) {
                    // Check if desc is not just "-"
                    const shortDesc = desc.length > 50 ? desc.substring(0, 47) + "..." : desc;
                    displayText += ` - ${shortDesc}`;
                }
                opt.innerText = displayText;
                matSelect.appendChild(opt);
            });

            // Show List View
            backToExList();
        }

        function filterExercises() {
            const term = document.getElementById('ex-search-input').value.toLowerCase();
            const catFilter = document.getElementById('filter-category').value;
            const matFilter = document.getElementById('filter-material').value;

            const items = document.querySelectorAll('#ex-list-ul .ex-list-item');
            items.forEach(li => {
                if (!li.dataset.search) return; // Custom item

                const matchesTerm = li.dataset.search.includes(term);
                const matchesCat = catFilter === "" || li.dataset.cat === catFilter;
                const matchesMat = matFilter === "" || li.dataset.mat === matFilter;

                if (matchesTerm && matchesCat && matchesMat) li.style.display = 'flex';
                else li.style.display = 'none';
            });
        }

        function showExDetail(item) {
            selectedDbItem = item;
            document.getElementById('ex-list-view').style.display = 'none';
            document.getElementById('ex-detail-view').style.display = 'flex';
            document.getElementById('ex-modal-title').innerText = "Bevestig";

            document.getElementById('detail-tit').innerText = item.exercise_name;
            document.getElementById('detail-meta').innerText = item.category || "Custom";
            document.getElementById('detail-desc').innerText = item.instructions || "Geen instructies.";

            const vidBtn = document.getElementById('detail-vid-btn');
            if (item.video_search_url) {
                vidBtn.style.display = 'flex';
                vidBtn.href = item.video_search_url;
            } else {
                vidBtn.style.display = 'none';
            }


        }

        function backToExList() {
            document.getElementById('ex-list-view').style.display = 'flex';
            document.getElementById('ex-detail-view').style.display = 'none';
            document.getElementById('ex-modal-title').innerText = "Kies Oefening";
        }

        function closeExerciseSelector() {
            document.getElementById('exercise-selector-modal').style.display = 'none';
            showScheduleModal(); // Return to previous modal
        }

        function confirmExerciseSelection() {
            if (!selectedDbItem || !currentExContext) return;

            const scopeRadios = document.getElementsByName('scope_sel');
            let scope = 'all_rounds';
            for (let r of scopeRadios) if (r.checked) scope = r.value;

            // Map scope to function args
            // 'all_rounds', 'set_all_rounds', 'single'
            // NOTE: 'round_ex' removed based on UI simplification, but we can re-add if needed.

            // Set input values for hidden fields used by applyNameChange
            document.getElementById('edit-round-idx').value = currentExContext.r;
            document.getElementById('edit-ex-idx').value = currentExContext.e;
            document.getElementById('edit-set-idx').value = currentExContext.s;
            document.getElementById('edit-new-val').value = selectedDbItem.exercise_name;

            applyNameChange(scope);
            closeExerciseSelector();
        }

        // --- OLD MODAL REMOVED - Adapter for applyNameChange remains same ---
        // (Function applyNameChange is reused)

        function closeEditScopeModal() {
            document.getElementById('edit-scope-modal').style.display = 'none';
            showScheduleModal();
        }

        function applyNameChange(scope) {
            const r = parseInt(document.getElementById('edit-round-idx').value);
            const e = parseInt(document.getElementById('edit-ex-idx').value);
            const s = parseInt(document.getElementById('edit-set-idx').value);
            const newVal = document.getElementById('edit-new-val').value;
            const totalRounds = parseInt(document.getElementById('rounds').value);

            if (scope === 'single') {
                const key = `r${r}-e${e}-s${s}`;
                if (newVal.trim() === "") delete customNames[key];
                else customNames[key] = newVal;
            }
            else if (scope === 'round_ex') {
                const key = `r${r}-e${e}`;
                if (newVal.trim() === "") delete customNames[key];
                else customNames[key] = newVal;
                // Cleanup specific set overrides for this round
                Object.keys(customNames).forEach(k => { if (k.startsWith(`r${r}-e${e}-s`)) delete customNames[k]; });
            }
            else if (scope === 'all_rounds') {
                for (let i = 1; i <= totalRounds; i++) {
                    const key = `r${i}-e${e}`;
                    if (newVal.trim() === "") delete customNames[key];
                    else customNames[key] = newVal;
                    // Cleanup specific set overrides
                    Object.keys(customNames).forEach(k => { if (k.startsWith(`r${i}-e${e}-s`)) delete customNames[k]; });
                }
            }
            else if (scope === 'set_all_rounds') {
                for (let i = 1; i <= totalRounds; i++) {
                    const key = `r${i}-e${e}-s${s}`;
                    if (newVal.trim() === "") delete customNames[key];
                    else customNames[key] = newVal;
                }
            }

            saveToLocal();
            // document.getElementById('edit-scope-modal').style.display = 'none'; // OLD MODAL REMOVED - Fixed crash
            // showScheduleModal(); // Handled by caller
        }

        function resetToDefaults() {
            if (!confirm("Weet je zeker dat je alle instellingen wilt resetten naar standaard?")) return;

            applyDefaultsToUI();

            customNames = {};

            // Custom Reset Logic: Start Time + 2min, Duration 45min, Rest 15s
            const now = new Date();
            now.setMinutes(now.getMinutes() + 2);
            // Format HH:MM
            const startStr = now.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', hour12: false });
            document.getElementById('startTimeValue').value = startStr;

            // Ensure 45m exists and set it
            const durSel = document.getElementById('totalMin');
            const targetDur = 45;
            let exists = false;
            for (let i = 0; i < durSel.options.length; i++) { if (parseInt(durSel.options[i].value) === targetDur) exists = true; }
            if (!exists) {
                const opt = document.createElement('option');
                opt.value = targetDur;
                opt.text = targetDur + "m";
                durSel.add(opt, 0); // Add at top or sorted? Logic usually adds at top if missing.
            }
            durSel.value = targetDur;

            // Set Rest Time to 15s
            document.getElementById('restSec').value = 15;

            // Set Exercises to 8
            document.getElementById('exercises').value = 8;

            syncTime('duration'); // Updates End Time based on Start + Duration
            setAudioMode('speech');
            if (document.getElementById('coach-preset-live')) document.getElementById('coach-preset-live').value = 'eva'; // UPDATED

            // Reset settings (Except Audio Mode)
            // Force Tabataman & Enable Milestones on Reset
            // Enable Milestones in Global Settings
            ['mile_start', 'mile_half', 'mile_end'].forEach(k => {
                if (!speechSettings[k]) speechSettings[k] = {};
                speechSettings[k].enabled = true;
            });
            renderAudioToggles();

            saveToLocal();
            calculateRealTime();
        }

        function applyTabataPreset() {
            if (!confirm("Huidige instellingen overschrijven met Tabata preset?")) return;

            const nowT = new Date();
            nowT.setMinutes(nowT.getMinutes() + 2);
            const startStrT = nowT.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
            document.getElementById('startTimeValue').value = startStrT;

            document.getElementById('totalMin').value = 4;

            // Tabata Specifics:
            // 4 min Duration
            // 1 Round
            // 8 Exercises
            // 1 Set
            // 10s Rest (Switch)
            // (Implicit: 20s Work Time calculated automatically)

            // Ensure 4m exists
            const durSel = document.getElementById('totalMin');
            const targetDur = 4;
            let exists = false;
            for (let i = 0; i < durSel.options.length; i++) { if (parseInt(durSel.options[i].value) === targetDur) exists = true; }
            if (!exists) {
                const opt = document.createElement('option');
                opt.value = targetDur; opt.text = targetDur + "m";
                durSel.add(opt, 0);
            }
            durSel.value = targetDur;

            document.getElementById('rounds').value = 1;
            document.getElementById('exercises').value = 8;
            document.getElementById('sets').value = 1;
            document.getElementById('exerciseRestSec').value = 10;

            document.getElementById('exerciseRestSec').value = 10;



            // We don't touch other Rests unless needed. 
            // Standard Tabata usually implies short rests. 
            // But user only specified Switch Rest 10s.

            // Sync to update End Time
            syncTime('duration');

            // Milestones remain unchanged

            calculateRealTime();
            saveToLocal();
        }

        // --- AI GENERATOR LOGIC ---
        let globalCoachAudio = new Audio();
        let audioCache = {}; // Cache for Web Audio buffers (Mix Mode)
        let iosMixMode = true; // Default ON (v1.5)
        let genLogic = { set: 'same', round: 'same' };

        // Show Mix Mode toggle only on iOS & Add Resumption Listeners
        if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
            // UI Toggle removed (Always On requested)

            // Auto-Resume AudioContext on Tab Focus/Return
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) wakeUpAudio();
            });

            // Re-unlock on any touch (ensure playback)
            document.addEventListener('touchstart', () => {
                wakeUpAudio();
            }, { passive: true });
        }

        function wakeUpAudio() {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended' || audioCtx.state === 'interrupted') {
                audioCtx.resume().then(() => logAudioDebug("⚡ Audio Resumed (WakeUp)"));
            }
            // Force silent oscillator to wake up iOS Audio Engine
            try {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                g.gain.value = 0; // Silent
                osc.connect(g);
                g.connect(audioCtx.destination);
                osc.start(0);
                osc.stop(audioCtx.currentTime + 0.01);
            } catch (e) { /* ignore */ }
        }



        function openGeneratorModal() {
            document.getElementById('generator-modal').style.display = 'flex';
            populateGeneratorOptions();
        }

        function closeGeneratorModal() {
            document.getElementById('generator-modal').style.display = 'none';
        }

        function toggleGenCheckboxes(name, state) {
            document.querySelectorAll(`input[name="${name}"]`).forEach(cb => cb.checked = state);
        }

        function setGenLogic(type, val, el) {
            genLogic[type] = val;
            // Update UI
            const group = el.parentElement;
            group.querySelectorAll('.gen-radio-opt').forEach(opt => opt.classList.remove('active'));
            el.classList.add('active');
        }

        function populateGeneratorOptions() {
            const matList = document.getElementById('gen-materials-list');
            const catList = document.getElementById('gen-categories-list');
            matList.innerHTML = "";
            catList.innerHTML = "";

            if (typeof WORKOUT_DB === 'undefined') {
                matList.innerHTML = "Database niet geladen.";
                return;
            }

            const cats = new Set();
            const mats = new Map(); // Name -> Description

            WORKOUT_DB.forEach(item => {
                if (item.category) cats.add(item.category);
                if (item.material_name) {
                    // Use Map to store unique materials with their description
                    if (!mats.has(item.material_name)) {
                        mats.set(item.material_name, item.material_description || "");
                    }
                }
            });

            // Populate Materials
            Array.from(mats.keys()).sort().forEach(m => {
                const desc = mats.get(m);
                const div = document.createElement('div');
                div.className = 'gen-checkbox-item';

                let labelHtml = `<span style="font-weight:bold; color:#fff;">${m}</span>`;
                if (desc) {
                    labelHtml += `<span style="color:#888; margin-left:8px; font-style:italic;">${desc}</span>`;
                }

                div.innerHTML = `<input type="checkbox" name="gen_mat" value="${m}" checked> ${labelHtml}`;
                matList.appendChild(div);
            });

            // Populate Categories
            Array.from(cats).sort().forEach(c => {
                const div = document.createElement('div');
                div.className = 'gen-checkbox-item';
                div.innerHTML = `<input type="checkbox" name="gen_cat" value="${c}" checked> <span style="font-weight:bold; color:#fff;">${c}</span>`;
                catList.appendChild(div);
            });
        }

        // Helper Shuffle (Fisher-Yates)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function runGenerator() {
            if (typeof WORKOUT_DB === 'undefined') { alert("Database error"); return; }

            // 1. Get Settings
            const rounds = parseInt(document.getElementById('rounds').value);
            const exPerRound = parseInt(document.getElementById('exercises').value);
            const sets = parseInt(document.getElementById('sets').value);

            // 2. Get Filters & SHUFFLE THEM
            // Shuffling ensures we don't always start with "Bodyweight" if checked.
            let selectedMats = Array.from(document.querySelectorAll('input[name="gen_mat"]:checked')).map(cb => cb.value);
            let selectedCats = Array.from(document.querySelectorAll('input[name="gen_cat"]:checked')).map(cb => cb.value);

            selectedMats = shuffleArray(selectedMats);
            selectedCats = shuffleArray(selectedCats);

            if (selectedMats.length === 0 || selectedCats.length === 0) {
                alert("Selecteer ten minste 1 materiaal en 1 categorie.");
                return;
            }

            // 3. Clear existing custom names
            if (!confirm("Dit overschrijft alle handmatige aanpassingen in het schema. Doorgaan?")) return;
            customNames = {};

            // 4. Generation Loop
            const usedIds = new Set(); // To ensure uniqueness across the whole workout

            // Helper to get candidate
            const getCandidate = (mat, catList, excludeIds) => {
                let candidates = WORKOUT_DB.filter(item =>
                    item.material_name === mat &&
                    catList.includes(item.category) &&
                    !excludeIds.has(item.id)
                );

                if (candidates.length === 0) {
                    // Try relaxing the ID constraint if we ran out of exercises
                    // Use a slightly different shuffle for fallback to keep it random
                    let backupCandidates = WORKOUT_DB.filter(item =>
                        item.material_name === mat &&
                        catList.includes(item.category)
                    );
                    if (backupCandidates.length > 0) {
                        return shuffleArray(backupCandidates)[0];
                    }
                    return null;
                }

                return shuffleArray(candidates)[0];
            };

            // Logic:
            // We iterate Rounds -> Exercises.
            // Material Priority: The user list order. Ex 1 = Mat 1, Ex 2 = Mat 2... cycling.

            let r1Matrix = [];

            for (let r = 1; r <= rounds; r++) {
                let roundExList = []; // Store for this round

                if (r > 1 && genLogic.round === 'same') {
                    // Copy Round 1 Logic
                } else {
                    // Generate New Round
                    for (let e = 1; e <= exPerRound; e++) {
                        // Determine Material (Cyclic)
                        const matIndex = (e - 1) % selectedMats.length;
                        const targetMat = selectedMats[matIndex];

                        // Determine Sets
                        let exForSet1 = getCandidate(targetMat, selectedCats, usedIds);
                        let set1Name = exForSet1 ? exForSet1.exercise_name : `Geen Oefening (${targetMat})`;

                        if (exForSet1) usedIds.add(exForSet1.id);

                        let setNames = [];
                        setNames.push(set1Name);

                        for (let s = 2; s <= sets; s++) {
                            if (genLogic.set === 'same') {
                                setNames.push(set1Name);
                            } else {
                                let exNext = getCandidate(targetMat, selectedCats, usedIds);
                                let nextName = exNext ? exNext.exercise_name : `Geen Oefening (${targetMat})`;
                                if (exNext) usedIds.add(exNext.id);
                                setNames.push(nextName);
                            }
                        }
                        roundExList.push(setNames);
                    }

                    if (r === 1) r1Matrix = roundExList;
                }

                // Apply to customNames
                for (let e = 1; e <= exPerRound; e++) {
                    for (let s = 1; s <= sets; s++) {
                        let finalName = "";
                        if (genLogic.round === 'same') {
                            // Use R1
                            if (r1Matrix[e - 1] && r1Matrix[e - 1][s - 1]) finalName = r1Matrix[e - 1][s - 1];
                        } else {
                            // Use Generated
                            if (roundExList[e - 1] && roundExList[e - 1][s - 1]) finalName = roundExList[e - 1][s - 1];
                        }

                        if (finalName) {
                            const key = `r${r}-e${e}-s${s}`;
                            customNames[key] = finalName;
                        }
                    }
                }
            }

            saveToLocal();
            closeGeneratorModal();
            showScheduleModal(); // Show result
        }

        async function shareSchedulePDF() {
            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                // Title
                doc.setFontSize(18);
                doc.text("Friday Night Hawks Training", 14, 20);
                doc.setFontSize(10);
                doc.text(`Gegenereerd op: ${new Date().toLocaleString('nl-NL')}`, 14, 26);

                const tableData = [];
                let currentTime = new Date();

                schedule.forEach(step => {
                    if (step.type === 'finish') return;

                    const timeStr = currentTime.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

                    let exName = step.label;
                    let detailsText = "";
                    let videoLink = "";
                    let shortsLink = "";

                    if (step.type === 'work' && step.info.exercise > 0) {
                        const details = getExerciseDetails(exName);
                        if (details) {
                            const matName = details.material_name || "-";
                            const matDesc = details.material_description || "";
                            const instr = details.instructions || "";

                            detailsText = `MATERIAAL: ${matName}\n\n${matDesc}\n\nINSTRUCTIE:\n${instr}`;

                            // Links
                            const vidUrl = details.video_search_url || "";
                            videoLink = vidUrl; // Modified: Removed the "shorts" fallback
                        }
                    } else {
                        detailsText = step.label;
                        if (step.info && step.info.round) detailsText += ` (R${step.info.round}/E${step.info.exercise})`;
                    }

                    tableData.push([timeStr, exName, detailsText, { video: videoLink }]); // Modified: Removed shortsLink
                    currentTime.setSeconds(currentTime.getSeconds() + step.time);
                });

                // Generate Table Data for PDF
                // We map the rich data to a format suitable for the PDF table, including clickable links.

                const finalBody = tableData.map(row => {
                    const linkObj = row[3];
                    let linkText = "";
                    if (linkObj.video) linkText += "VIDEO";
                    // if (linkObj.shorts) linkText += (linkText ? "\n\n" : "") + "SHORTS"; // Removed
                    // Pass object to preserve link data in cell.raw
                    return [row[0], row[1], row[2], { content: linkText, links: linkObj }];
                });

                doc.autoTable({
                    head: [['Tijd', 'Oefening', 'Details', 'Links']],
                    body: finalBody,
                    startY: 35,
                    styles: { fontSize: 8, cellPadding: 3, overflow: 'linebreak' },
                    columnStyles: {
                        0: { cellWidth: 20 },
                        1: { cellWidth: 35, fontStyle: 'bold' },
                        2: { cellWidth: 'auto' },
                        3: { cellWidth: 25, halign: 'center', textColor: [10, 132, 255] }
                    },
                    didDrawCell: function (data) {
                        if (data.column.index === 3 && data.cell.section === 'body') {
                            // Safely access embedded link data
                            const raw = data.cell.raw;
                            if (raw && raw.links && (raw.links.video || raw.links.shorts)) {
                                const linkObj = raw.links;
                                const x = data.cell.x;
                                const y = data.cell.y;
                                const w = data.cell.width;
                                const h = data.cell.height;

                                // Link Areas
                                if (linkObj.video) {
                                    doc.link(x, y, w, h / 2, { url: linkObj.video });
                                }
                                if (linkObj.shorts) {
                                    doc.link(x, y + h / 2, w, h / 2, { url: linkObj.shorts });
                                }
                            }
                        }
                    }
                });

                const pdfBlob = doc.output('blob');
                const file = new File([pdfBlob], "fnh_schema.pdf", { type: "application/pdf" });

                if (navigator.share) {
                    try {
                        await navigator.share({
                            files: [file],
                            title: 'FNH Training Schema',
                            text: 'Hier is het schema voor vanavond!'
                        });
                    } catch (err) {
                        console.log("Share failed or cancelled", err);
                        doc.save("fnh_schema.pdf");
                    }
                } else {
                    doc.save("fnh_schema.pdf");
                }
            } catch (error) {
                console.error("PDF Error:", error);
                alert("Er is een fout opgetreden bij het maken van de PDF:\n" + error.message);
            }
        }

        function shareApp() {
            const cleanUrl = window.location.origin + window.location.pathname;
            let text = "🦅 **FNH Timer: De enige timer die terugrekent!**\n\n";
            text += "🏁 **Jij kiest de eindtijd, de app doet de rest.**\n";
            text += "Hij berekent automatisch de werk- en rusttijden zodat je precies op tijd klaar bent. Nooit meer gokken of haasten.\n\n";
            text += "✅ **Waarom deze app?**\n";
            text += "- ⏳ **Aftellen tot start:** Zie precies hoe lang je nog hebt voor uitleg of warming-up. De training start automatisch!\n";
            text += "- 🍦 **Trainer Logica:** Snapt bonussen, 'toetjes' en onderscheidt rust vs. wisselen.\n";
            text += "- 💾 **PDF & Instellingen:** Deel het schema als PDF (voorbereiding) of de link voor directe toegang tot de instellingen.\n";
            text += "- 🤖 **AI Generator:** Maakt direct een training op basis van jouw materialen.\n";
            text += "- 🗣️ **Kies je Coach:** Meerdere stijlen met natuurlijk klinkende en gevarieerde spraak.\n";
            text += "- 🛠️ Pas live tijden aan (zonder rekenen)\n";
            text += "- 🎧 Muziek blijft aanstaan (Mix-mode)\n";
            text += "- 📱 **Draait op alles:** Werkt op iOS, Android, Windows en Mac.\n";
            text += "- 🚀 **Geen installatie:** Werkt direct in je browser (Web App)!\n\n";
            text += "👇 **Gebruik 'm hier (gratis):**";

            if (navigator.share) {
                navigator.share({
                    title: "FNH Timer 🦅",
                    text: text,
                    url: cleanUrl
                }).catch(console.error);
            } else {
                navigator.clipboard.writeText(text + "\n" + cleanUrl).then(() => alert("Tekst en link gekopieerd!"));
            }
        }

        function shareSettings() {
            const rounds = document.getElementById('rounds').value; const exercises = document.getElementById('exercises').value; const sets = document.getElementById('sets').value;
            const restSec = document.getElementById('restSec').value; const exerciseRestSec = document.getElementById('exerciseRestSec').value; const roundRestSec = document.getElementById('roundRestSec').value;
            const totalMin = document.getElementById('totalMin').value;

            // NEW: Capture additional settings
            const startTime = document.getElementById('startTimeValue').value;
            const coach = document.getElementById('coach-preset-live') ? document.getElementById('coach-preset-live').value : 'eva'; // UPDATED


            const params = new URLSearchParams();
            params.set('r', rounds); params.set('e', exercises); params.set('s', sets);
            params.set('rs', restSec); params.set('re', exerciseRestSec); params.set('rr', roundRestSec); params.set('tm', totalMin);

            if (startTime) params.set('st', startTime);
            if (coach) params.set('c', coach);

            // Bonus Settings
            for (let i = 1; i <= 3; i++) {
                const name = document.getElementById(`bonus${i}-name`).value;
                const dur = document.getElementById(`bonus${i}-duration`).value;
                const freq = document.getElementById(`bonus${i}-freq`).value;
                if (name) params.set(`b${i}n`, name);
                if (dur) params.set(`b${i}d`, dur);
                if (freq) params.set(`b${i}f`, freq);
            }

            // Custom Names (Full Schedule)
            if (Object.keys(customNames).length > 0) {
                try {
                    const cnStr = JSON.stringify(customNames);
                    params.set('cn', encodeURIComponent(cnStr));
                } catch (e) { console.error("Error serializing customNames", e); }
            }

            for (const [key, value] of Object.entries(speechSettings)) { if (value.text) { params.set(key, value.text); } }
            const baseUrl = window.location.origin + window.location.pathname; const shareUrl = baseUrl + '?' + params.toString();
            if (navigator.share) { navigator.share({ title: 'FNH Training Settings', url: shareUrl }).catch(console.error); }
            else { navigator.clipboard.writeText(shareUrl).then(() => { alert("Link met instellingen gekopieerd!"); }); }
        }

        function checkForSharedSettings() {
            const params = new URLSearchParams(window.location.search);
            let dataUpdated = false;
            if (params.has('r')) {
                document.getElementById('rounds').value = params.get('r'); document.getElementById('exercises').value = params.get('e'); document.getElementById('sets').value = params.get('s');
                document.getElementById('restSec').value = params.get('rs'); document.getElementById('exerciseRestSec').value = params.get('re'); document.getElementById('roundRestSec').value = params.get('rr');
                document.getElementById('totalMin').value = params.get('tm'); dataUpdated = true;
            }

            // Restore new settings
            if (params.has('st')) { document.getElementById('startTimeValue').value = params.get('st'); dataUpdated = true; }

            if (params.has('c')) {
                const coachVal = params.get('c');
                const coachEl = document.getElementById('coach-preset-live'); // UPDATED
                if (coachEl && coachEl.querySelector(`option[value="${coachVal}"]`)) {
                    coachEl.value = coachVal;
                    // We must trigger this to load audio/speech settings for the coach
                    applyCoachPreset(coachVal);
                    dataUpdated = true;
                }
            }

            // Restore Bonus Settings
            for (let i = 1; i <= 3; i++) {
                if (params.has(`b${i}n`)) { document.getElementById(`bonus${i}-name`).value = params.get(`b${i}n`); dataUpdated = true; }
                if (params.has(`b${i}d`)) { document.getElementById(`bonus${i}-duration`).value = params.get(`b${i}d`); dataUpdated = true; }
                if (params.has(`b${i}f`)) { document.getElementById(`bonus${i}-freq`).value = params.get(`b${i}f`); dataUpdated = true; }
            }

            // Restore Custom Names (Full Schedule)
            if (params.has('cn')) {
                try {
                    const cnStr = decodeURIComponent(params.get('cn'));
                    const parsed = JSON.parse(cnStr);
                    // Merge or replace? Let's replace to ensure exact schedule replication
                    if (parsed) {
                        customNames = parsed;
                        dataUpdated = true;
                    }
                } catch (e) { console.error("Failed to parse custom names", e); }
            }

            let speechUpdated = false;
            for (const key in speechSettings) { if (params.has(key)) { speechSettings[key].text = params.get(key); speechUpdated = true; dataUpdated = true; } }
            if (speechUpdated) { const dropdown = document.getElementById('coach-preset-live'); if (dropdown) { dropdown.value = 'custom'; if (dropdown.querySelector('option[value="custom"]')) { dropdown.querySelector('option[value="custom"]').removeAttribute('hidden'); dropdown.querySelector('option[value="custom"]').removeAttribute('disabled'); } } } // UPDATED


            if (dataUpdated) {
                // Restore visibility of bonuses if needed
                if (typeof updateBonusVisibility === 'function') updateBonusVisibility();

                syncTime('duration');
                saveToLocal();
            }
        }

        function saveToLocal() {
            const data = {
                rounds: document.getElementById('rounds').value, exercises: document.getElementById('exercises').value, sets: document.getElementById('sets').value,
                restSec: document.getElementById('restSec').value, exerciseRestSec: document.getElementById('exerciseRestSec').value, roundRestSec: document.getElementById('roundRestSec').value,
                totalMin: document.getElementById('totalMin').value, audioMode: audioMode,
                speechSettings: speechSettings, // v1.16: Restore Save
                startTimeValue: document.getElementById('startTimeValue').value, // NEW
                speechSettings: speechSettings, // v1.16: Restore Save
                startTimeValue: document.getElementById('startTimeValue').value, // NEW
                coachPreset: document.getElementById('coach-preset-live') ? document.getElementById('coach-preset-live').value : (appDefaults.coachPreset || 'eva'), // Save Coach Selection (Live or Default)
                startRound: document.getElementById('start-round').value, startEx: document.getElementById('start-ex').value, startSet: document.getElementById('start-set').value,
                startRound: document.getElementById('start-round').value, startEx: document.getElementById('start-ex').value, startSet: document.getElementById('start-set').value,
                iosMixMode: iosMixMode, // Save Mix Mode setting
                // Save 3 Bonuses
                bonus1: { name: document.getElementById('bonus1-name').value, dur: document.getElementById('bonus1-duration').value, freq: document.getElementById('bonus1-freq').value },
                bonus2: { name: document.getElementById('bonus2-name').value, dur: document.getElementById('bonus2-duration').value, freq: document.getElementById('bonus2-freq').value },
                bonus3: { name: document.getElementById('bonus3-name').value, dur: document.getElementById('bonus3-duration').value, freq: document.getElementById('bonus3-freq').value },
                // Save Custom Names
                customNames: customNames
            };
            localStorage.setItem('fnh_settings_v8', JSON.stringify(data));
        }

        function loadFromLocal() {
            const saved = localStorage.getItem('fnh_settings_v8');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    document.getElementById('rounds').value = data.rounds || 2; document.getElementById('exercises').value = data.exercises || 6; document.getElementById('sets').value = data.sets || 2;
                    document.getElementById('restSec').value = data.restSec || 20; document.getElementById('exerciseRestSec').value = data.exerciseRestSec || 30; document.getElementById('roundRestSec').value = data.roundRestSec || 90;
                    document.getElementById('totalMin').value = data.totalMin || 30;
                    if (data.startTimeValue) document.getElementById('startTimeValue').value = data.startTimeValue;
                    if (data.startRound) document.getElementById('start-round').value = data.startRound;
                    if (data.startEx) document.getElementById('start-ex').value = data.startEx;
                    if (data.startSet) document.getElementById('start-set').value = data.startSet;

                    if (data.bonus1) { document.getElementById('bonus1-name').value = data.bonus1.name; document.getElementById('bonus1-duration').value = data.bonus1.dur; document.getElementById('bonus1-freq').value = data.bonus1.freq; }
                    if (data.bonus2) { document.getElementById('bonus2-name').value = data.bonus2.name; document.getElementById('bonus2-duration').value = data.bonus2.dur; document.getElementById('bonus2-freq').value = data.bonus2.freq; }
                    if (data.bonus3) { document.getElementById('bonus3-name').value = data.bonus3.name; document.getElementById('bonus3-duration').value = data.bonus3.dur; document.getElementById('bonus3-freq').value = data.bonus3.freq; }

                    if (data.customNames) customNames = data.customNames;

                    // Restore Volumes
                    if (data.volMusic) {
                        try { document.getElementById('vol-music').value = data.volMusic; } catch (e) { } // Removed element
                        if (document.getElementById('vol-music-live')) document.getElementById('vol-music-live').value = data.volMusic;
                        bgMusicManager.audio.volume = parseFloat(data.volMusic);
                    }
                    if (data.volCoach) {
                        try { document.getElementById('vol-coach').value = data.volCoach; } catch (e) { } // Removed element
                        if (document.getElementById('vol-coach-live')) document.getElementById('vol-coach-live').value = data.volCoach;
                    }

                    // Restore Coach Preset
                    if (data.coachPreset) {
                        const sel = document.getElementById('coach-preset-live'); // UPDATED
                        // Only set if option exists
                        if (sel && sel.querySelector(`option[value="${data.coachPreset}"]`)) {
                            sel.value = data.coachPreset;
                        }
                    }

                    // Restore Mix Mode (Always ON now)
                    iosMixMode = true;

                    if (data.audioMode) setAudioMode(data.audioMode);
                    // v1.16: Restore speechSettings load
                    if (data.speechSettings) {
                        for (const key in speechSettings) {
                            if (data.speechSettings[key]) {
                                speechSettings[key].enabled = data.speechSettings[key].enabled;
                            }
                        }
                        // Also Add keys that might be in data but not in current preset (though standardizing via uiConfig is better)
                        for (const key in data.speechSettings) {
                            if (!speechSettings[key]) speechSettings[key] = data.speechSettings[key];
                        }

                        // FIX: Ensure critical keys exist to prevent 'undefined' errors
                        const requiredKeys = ['rest_set_tips', 'rest_switch_info', 'rest_round_info'];
                        requiredKeys.forEach(k => {
                            if (!speechSettings[k]) speechSettings[k] = { enabled: true };
                        });
                    }

                } catch (e) { console.log("Error loading settings", e); }
            }
        }

        function updatevolumes() {
            const mv = parseFloat(document.getElementById('vol-music').value);
            const cv = parseFloat(document.getElementById('vol-coach').value);

            // Music
            bgMusicManager.audio.volume = mv;
            localStorage.setItem('fnh_vol_music', mv);
        }



        function updateLiveVolumes() {
            const mv = parseFloat(document.getElementById('vol-music-live').value);
            const mr = parseFloat(document.getElementById('vol-music-rest-live').value);
            const cv = parseFloat(document.getElementById('vol-coach-live').value);



            // Update Manager
            if (bgMusicManager && bgMusicManager.updateVolumes) {
                bgMusicManager.updateVolumes(mv, mr);
            } else {
                // Fallback
                bgMusicManager.audio.volume = mv;
            }

            localStorage.setItem('fnh_vol_music', mv);
            localStorage.setItem('fnh_vol_music_rest', mr);
            localStorage.setItem('fnh_vol_coach', cv);
        }

        function setAudioMode(newMode) {
            audioMode = newMode;
            updateLiveAudioUI();
            renderAudioToggles(); // Re-render logic toggles (if visible elsewhere)
        }

        function updateLiveAudioUI() {
            const btnSpeech = document.getElementById('btn-audio-speech-live');
            const btnBeep = document.getElementById('btn-audio-beep-live');
            if (btnSpeech) btnSpeech.className = (audioMode === 'speech') ? 'toggle-btn active' : 'toggle-btn';
            if (btnBeep) btnBeep.className = (audioMode === 'beep') ? 'toggle-btn active' : 'toggle-btn';


        }

        function populateLiveCoachSelect() {
            const sel = document.getElementById('coach-preset-live');
            if (!sel || sel.options.length > 0) return; // Already populated

            sel.innerHTML = "";
            for (const [key, val] of Object.entries(coachPresets)) {
                // Determine display name
                let name = key;
                if (key === 'default') name = "Standaard (Tabataman)";
                if (key === 'tabataman') name = "Tabataman (Orgineel)";
                if (key === 'drill_sergeant') name = "Drill Sergeant (Intens)";
                if (key === 'zen_master') name = "Zen Master (Rust)";
                // Use a generic formatter if defined, else raw key

                const opt = document.createElement('option');
                opt.value = key;
                opt.innerText = name; // simplified naming logic
                if (key === 'tabataman') opt.innerText = "Tabataman (Standaard)"; // Manual override matches previous

                sel.appendChild(opt);
            }
            // Set current value
            const current = appDefaults.coachPreset || 'eva';
            // We should get the ACTUAL current, not just default. 
            // But coach logic is a bit scattered. Let's assume 'eva' if unset.
            sel.value = document.getElementById('coach-preset') ? document.getElementById('coach-preset').value : current;
        }

        function toggleVolumePanel() {
            const el = document.getElementById('active-volume-panel');
            if (el.style.display === 'none') {
                el.style.display = 'block';

                // 1. Sync Volumes
                const savedMus = localStorage.getItem('fnh_vol_music');
                const savedMusRest = localStorage.getItem('fnh_vol_music_rest');
                const savedCoach = localStorage.getItem('fnh_vol_coach');

                if (savedMus) document.getElementById('vol-music-live').value = savedMus;
                if (savedMusRest) document.getElementById('vol-music-rest-live').value = savedMusRest;
                if (savedCoach) document.getElementById('vol-coach-live').value = savedCoach;

                // Force Update Text & Manager with newly set values
                updateLiveVolumes();

                // 2. Populate Coach & Sync UI
                populateLiveCoachSelect();
                updateLiveAudioUI();
                renderAudioToggles(); // Ensure Speech Toggles are rendered

                // 3. Render Genres
                if (bgMusicManager) bgMusicManager.renderGenreToggles('audio-settings-genres');

                // 4. Sync Coach Select Value
                // Verify we have the latest stored or default
                // The 'coach-preset' element was removed, so we rely on global state or LocalStorage?
                // Coach state is in `speechSettings` but that's the CONTENT.
                // The selected preset key isn't stored in a global var explicitly other than the select value.
                // FIX: We need to ensure we know the current coach.
                // Let's grab it from localstorage or default.
                // We likely saved it? `saveToLocal` saves `coach-preset` ID value.
                // Let's add a robust retrieval.

                // For now, let's just ensure the select reflects what might be saved
                // Since we rely on applyCoachPreset to set state.

            } else {
                el.style.display = 'none';
            }
        }

        function calculateRealTime() {
            const rounds = parseInt(document.getElementById('rounds').value) || 1; const ex = parseInt(document.getElementById('exercises').value) || 0; const sts = parseInt(document.getElementById('sets').value) || 0;
            // FIX: Robust Input Parsing (Prevent 0 default if value is missing/hidden)
            let rst = parseInt(document.getElementById('restSec').value);
            if (isNaN(rst)) rst = appDefaults.restSec;

            let exRst = parseInt(document.getElementById('exerciseRestSec').value);
            if (isNaN(exRst)) exRst = appDefaults.exerciseRestSec;

            let roundRst = parseInt(document.getElementById('roundRestSec').value);
            if (isNaN(roundRst)) roundRst = appDefaults.roundRestSec;
            const startRound = parseInt(document.getElementById('start-round').value) || 1; const startEx = parseInt(document.getElementById('start-ex').value) || 1; const startSet = parseInt(document.getElementById('start-set').value) || 1;

            if (ex === 0 || sts === 0 || rounds === 0) return;

            let remainingWorkSets = 0; let remainingFixedRestTime = 0;

            // BONUS LOGIC CALCULATION (Loop 3 bonuses)
            // Warmup Check (Start of Session)
            for (let b = 1; b <= 3; b++) {
                const bMin = parseInt(document.getElementById(`bonus${b}-duration`).value) || 0;
                const bFreq = document.getElementById(`bonus${b}-freq`).value;
                if (bMin > 0 && bFreq === 'warmup') {
                    if (startRound === 1 && startEx === 1 && startSet === 1) {
                        remainingFixedRestTime += (bMin * 60) + exRst;
                    }
                }
            }



            // Toetje Check (End of Session)
            for (let b = 1; b <= 3; b++) {
                const bMin = parseInt(document.getElementById(`bonus${b}-duration`).value) || 0;
                const bFreq = document.getElementById(`bonus${b}-freq`).value;
                if (bMin > 0 && bFreq === 'end_session') {
                    // Toetje NO REST after
                    remainingFixedRestTime += (bMin * 60) + exRst; // Added exRst here to account for the "switch" after bonus
                }
            }



            let globalExCount = 0;

            for (let r = 1; r <= rounds; r++) {

                // Start Round Check
                // Start Round Check
                for (let b = 1; b <= 3; b++) {
                    const bonus = getBonusData(b);
                    if (bonus.min > 0 && bonus.freq === 'start_round') {
                        if (r >= startRound) {
                            if (r > startRound || (r === startRound && startEx === 1 && startSet === 1)) {
                                remainingFixedRestTime += (bonus.min * 60) + exRst;
                            }
                        }
                    }
                }

                for (let e = 1; e <= ex; e++) {
                    globalExCount++;

                    // Interval Check
                    // Interval Check
                    for (let b = 1; b <= 3; b++) {
                        const bonus = getBonusData(b);
                        if (bonus.min > 0 && !isNaN(bonus.freq) && (globalExCount % parseInt(bonus.freq) === 0)) {
                            let isFuture = false;
                            if (r > startRound) isFuture = true; else if (r === startRound && e > startEx) isFuture = true; else if (r === startRound && e === startEx && sts >= startSet) isFuture = true;
                            if (isFuture) remainingFixedRestTime += (bonus.min * 60) + exRst;
                        }
                    }

                    for (let s = 1; s <= sts; s++) {
                        let isFuture = false; if (r > startRound) isFuture = true; else if (r === startRound && e > startEx) isFuture = true; else if (r === startRound && e === startEx && s >= startSet) isFuture = true;
                        if (isFuture) {
                            remainingWorkSets++;
                            const isLastSetOfWorkout = (r === rounds && e === ex && s === sts); const isLastSetOfRound = (e === ex && s === sts); const isLastSetOfExercise = (s === sts);
                            if (!isLastSetOfWorkout) { if (isLastSetOfRound) remainingFixedRestTime += roundRst; else if (isLastSetOfExercise) remainingFixedRestTime += exRst; else remainingFixedRestTime += rst; }
                        }
                    }
                }

                // End Round Check
                for (let b = 1; b <= 3; b++) {
                    const bonus = getBonusData(b);
                    if (bonus.min > 0 && bonus.freq === 'end_round') {
                        if (r >= startRound) {
                            remainingFixedRestTime += (bonus.min * 60) + exRst;
                        }
                    }
                }
            }

            remainingFixedRestTime += 10;

            let availableSec = 0;
            const startStr = document.getElementById('startTimeValue').value;
            const endStr = document.getElementById('endTimeValue').value;



            if (endStr) {
                const now = new Date();
                let base = now;
                if (startStr) {
                    const [sh, sm] = startStr.split(':');
                    base = new Date();
                    base.setHours(sh, sm, 0, 0);
                }

                const [h, m] = endStr.split(':');
                const target = new Date();
                target.setHours(h, m, 0, 0);

                if (target < base) target.setDate(target.getDate() + 1);
                availableSec = Math.floor((target - base) / 1000);
            }

            const workSecTotal = availableSec - remainingFixedRestTime;



            const btnEl = document.getElementById('btn-start-app'); const errEl = document.getElementById('live-calc-error'); const resEl = document.getElementById('live-calc-result');

            if (workSecTotal <= 0 || remainingWorkSets <= 0) {
                resEl.innerText = "--"; errEl.style.display = "block"; btnEl.style.opacity = 0.5; btnEl.disabled = true; workTimeSec = 0;
                document.getElementById('preview-list').innerHTML = "<div style='padding:10px; color:#555;'>Geen schema mogelijk</div>";
            } else {
                workTimeSec = Math.floor(workSecTotal / remainingWorkSets);
                resEl.innerText = workTimeSec + "s"; errEl.style.display = "none"; btnEl.style.opacity = 1; btnEl.disabled = false;
                restTimeSec = rst; exerciseRestSec = exRst; roundRestSec = roundRst;
                generateScheduleData(true); renderPreviewList();
            }
        }



        function generateScheduleData(applyResumeFilter) {
            const rounds = parseInt(document.getElementById('rounds').value); const ex = parseInt(document.getElementById('exercises').value); const sts = parseInt(document.getElementById('sets').value);
            const startRound = parseInt(document.getElementById('start-round').value); const startEx = parseInt(document.getElementById('start-ex').value); const startSet = parseInt(document.getElementById('start-set').value);
            const exerciseRestSec = parseInt(document.getElementById('exerciseRestSec').value);
            console.log("DEBUG_GEN (" + Date.now() + ")", { workTimeSec, exerciseRestSec, totalWorkSetsGlobal });

            totalWorkSetsGlobal = rounds * ex * sts; let currentSetGlobal = 0;
            schedule = []; schedule.push({ type: 'prep', time: 15, label: "Voorbereiden", initialTime: 15, info: { round: 1, exercise: 1, set: 1, maxRounds: rounds, maxEx: ex, maxSets: sts } });

            // Using global getBonusData helper now

            // WARMUP BONUS (Check all 3)
            for (let b = 1; b <= 3; b++) {
                const bonus = getBonusData(b);
                if (bonus.min > 0 && bonus.freq === 'warmup') {
                    if (!applyResumeFilter || (startRound === 1 && startEx === 1 && startSet === 1)) {
                        addBonusStep(0, bonus.name.toUpperCase(), bonus.min * 60, exerciseRestSec, bonus.id);
                    }
                }
            }

            let globalExCount = 0;

            for (let r = 1; r <= rounds; r++) {

                // START ROUND BONUS
                for (let b = 1; b <= 3; b++) {
                    const bonus = getBonusData(b);
                    if (bonus.min > 0 && bonus.freq === 'start_round') {
                        let include = true;
                        if (applyResumeFilter) {
                            if (r < startRound) include = false;
                            else if (r === startRound && (startEx > 1 || startSet > 1)) include = false;
                        }
                        if (include) addBonusStep(r, bonus.name.toUpperCase(), bonus.min * 60, exerciseRestSec, bonus.id);
                    }
                }

                for (let e = 1; e <= ex; e++) {
                    globalExCount++;

                    // INTERVAL BONUS
                    for (let b = 1; b <= 3; b++) {
                        const bonus = getBonusData(b);
                        if (bonus.min > 0 && !isNaN(bonus.freq) && (globalExCount % parseInt(bonus.freq) === 0)) {
                            let include = true;
                            if (applyResumeFilter) { if (r < startRound) include = false; else if (r === startRound && e < startEx) include = false; else if (r === startRound && e === startEx && sts < startSet) include = false; }

                            if (include) addBonusStep(r, bonus.name.toUpperCase(), bonus.min * 60, exerciseRestSec, bonus.id);
                        }
                    }

                    for (let s = 1; s <= sts; s++) {
                        currentSetGlobal++; let include = true;
                        if (applyResumeFilter) { if (r < startRound) include = false; else if (r === startRound && e < startEx) include = false; else if (r === startRound && e === startEx && s < startSet) include = false; }
                        if (include) {
                            // CHECK FOR CUSTOM NAME
                            // Hierarchy: Specific Set > Round Exercise > All Round Exercise (handled by apply)
                            let label = `Oefening ${e}.${s}`;
                            const keySet = `r${r}-e${e}-s${s}`;
                            const keyRound = `r${r}-e${e}`;

                            if (customNames[keySet]) label = customNames[keySet];
                            else if (customNames[keyRound]) label = customNames[keyRound];

                            schedule.push({ type: 'work', time: workTimeSec, initialTime: workTimeSec, label: label, info: { round: r, exercise: e, set: s, maxRounds: rounds, maxEx: ex, maxSets: sts, globalSet: currentSetGlobal } });
                            const isLastSetOfWorkout = (r === rounds && e === ex && s === sts); const isLastSetOfRound = (e === ex && s === sts); const isLastSetOfExercise = (s === sts);
                            if (!isLastSetOfWorkout) {
                                let restLabel = "RUST"; let infoText = "";
                                if (isLastSetOfRound) { restLabel = "RONDE PAUZE"; infoText = "Even bijkomen..."; }
                                else if (isLastSetOfExercise) { restLabel = "WISSEL OEFENING"; infoText = `Op naar oefening ${e < ex ? e + 1 : 1}`; }
                                else { infoText = "Even ontspannen"; }
                                let type = isLastSetOfRound ? 'rest-long' : (isLastSetOfExercise ? 'rest-exercise' : 'rest');
                                schedule.push({ type: type, time: (isLastSetOfRound ? roundRestSec : (isLastSetOfExercise ? exerciseRestSec : restTimeSec)), initialTime: (isLastSetOfRound ? roundRestSec : (isLastSetOfExercise ? exerciseRestSec : restTimeSec)), label: restLabel, info: { round: r, exercise: e, set: s, maxRounds: rounds, maxEx: ex, maxSets: sts, text: infoText } });
                            }
                        }
                    }
                }

                // END ROUND BONUS
                for (let b = 1; b <= 3; b++) {
                    const bonus = getBonusData(b);
                    if (bonus.min > 0 && bonus.freq === 'end_round') {
                        let include = true;
                        if (applyResumeFilter && r < startRound) include = false;
                        if (include) addBonusStep(r, bonus.name.toUpperCase(), bonus.min * 60, exerciseRestSec, bonus.id);
                    }
                }
            }

            // TOETJE BONUS
            for (let b = 1; b <= 3; b++) {
                const bonus = getBonusData(b);
                if (bonus.min > 0 && bonus.freq === 'end_session') {
                    // TOETJE has NO rest/switch after!
                    schedule.push({
                        type: 'work',
                        time: bonus.min * 60,
                        initialTime: bonus.min * 60,
                        label: bonus.name.toUpperCase(),
                        info: { round: 0, exercise: 0, set: 0, globalSet: 0, bonusId: bonus.id }
                    });
                }
            }

            if (schedule.length > 1) schedule.push({ type: 'finish', time: 0, label: "KLAAR!", initialTime: 0, info: { text: "Goed gewerkt!" } }); else schedule = [];
        }

        // --- MUSIC UI RENDERER ---

        // --- MUSIC MANIFEST (Hardcoded) ---
        const musicManifest = {
            "Kaseko": {
                rust: [
                    "Bossa Breeze 11.mp3", "Caribbean Drift 04.mp3", "Caribbean Lounge 08.mp3", "Coral Reef 05.mp3",
                    "Deep Blue Rest 06.mp3", "Dreamy Steel 12.mp3", "Dubby Drift 09.mp3", "Island Acoustic 07.mp3",
                    "Island Calm 03.mp3", "Ocean Pan 14.mp3", "Reggae Rest 13.mp3", "Steelpan Breeze 01.mp3",
                    "Sunset Steel 16.mp3", "Tropical Float 02.mp3", "Tropical Recharge 10.mp3", "Weightless Pan 15.mp3"
                ],
                werk: [
                    "Island Velocity 03.mp3", "Kaseko Drive 04.mp3", "Kaseko Focus 12.mp3", "Kaseko Grind 07.mp3",
                    "Kaseko Limits 14.mp3", "Kaseko Power 01.mp3", "Kaseko Stamina 09.mp3", "Kaseko Warrior 11.mp3",
                    "Suri Sweat 06.mp3", "Tropical Burn 02.mp3", "Tropical Fire 08.mp3", "Tropical Force 05.mp3",
                    "Tropical Motion 16.mp3", "Tropical Power 15.mp3", "Tropical Rush 13.mp3", "Tropical Speed 10.mp3"
                ]
            },
            "Neue Deutsche Härte": {
                rust: [
                    "(Ein langes Zischen von Dampf).mp3",
                    "(Ein tiefer, gedämpfter Beat setzt sofor.mp3",
                    "(Langsam, Düster, Atmosphärisch).mp3",
                    "(Sehr langsam, Tief).mp3",
                    "(Tiefes Brummen der Motoren).mp3"
                ],
                werk: [
                    "BEFEHL IST BEFEHL!.mp3",
                    "DAS TIER!.mp3",
                    "DEUTSCHLAND!.mp3",
                    "DRECKIGER SCHWEINEKOPF!.mp3",
                    "DU BIST AUS STAHL!.mp3",
                    "EISEN!.mp3",
                    "HALT DIE FRESSE!.mp3",
                    "HAMMER!.mp3",
                    "HEUL NICHT!.mp3",
                    "NEIN!.mp3",
                    "PANZER!.mp3",
                    "VERDAMMTES ARSCHLOCH!.mp3"
                ]
            },
            "Phonk": {
                rust: [
                    "PhonkRelax1.mp3",
                    "PhonkRelax2.mp3",
                    "PhonkRelax3.mp3",
                    "PhonkRelax4.mp3"
                ],
                werk: [
                    "FASTER! FASTER!.mp3",
                    "FASTER!.mp3",
                    "FOCUS. 2.mp3",
                    "FOCUS..mp3",
                    "GO! PUSH IT TO THE LIMIT! NO MERCY! (WOR.mp3",
                    "GRIND!.mp3",
                    "KEEP IT MOVING!.mp3",
                    "STOMP! STOMP!.mp3",
                    "TOMA! TOMA! TOMA!.mp3"
                ]
            }
        };

        class BackgroundMusicManager {
            constructor() {
                this.audio = new Audio();
                this.audio.loop = false; // FIXED: No loop, auto-advance
                // Use new Live ID but fallback to storage
                const volInput = document.getElementById('vol-music-live');
                const volRestInput = document.getElementById('vol-music-rest-live');

                this.volWork = volInput ? parseFloat(volInput.value) : parseFloat(localStorage.getItem('fnh_vol_music') || 0.4);
                this.volRest = volRestInput ? parseFloat(volRestInput.value) : parseFloat(localStorage.getItem('fnh_vol_music_rest') || 0.2);

                this.audio.volume = this.volRest; // Default to rest volume initially
                this.audio.preload = 'auto'; // Ensure preload

                // FIXED: Load persisted genres
                const savedGenres = localStorage.getItem('fnh_selected_genres');
                this.selectedGenres = savedGenres ? JSON.parse(savedGenres) : [];
                this.enabledGenres = new Set(this.selectedGenres);

                // FIXED PLAYLIST QUEUES
                this.workQueue = [];
                this.restQueue = [];
                this.workIndex = 0;
                this.restIndex = 0;

                this.workIndex = 0;
                this.restIndex = 0;

                this.continuousMode = false;
                // Load continuous mode preference
                if (localStorage.getItem('fnh_continuous') === 'true') {
                    this.setContinuous(true);
                    setTimeout(() => {
                        const chk = document.getElementById('chk-continuous-music');
                        if (chk) chk.checked = true;
                    }, 500);
                }

                this.currentGenre = null;
                this.currentType = 'rust'; // Default
                this.hasStartedForWorkout = false;

                // Handle Track End for Continuous Mode
                // Handle Track End
                this.audio.onended = () => {
                    if (this.hasStartedForWorkout) {
                        // Workout Mode: Always play next track (Work or Rest)
                        this.playNext();
                    } else {
                        // Preview Mode: Loop single track
                        this.audio.currentTime = 0;
                        this.audio.play();
                    }
                };
            }

            setContinuous(enabled) {
                this.continuousMode = enabled;
                localStorage.setItem('fnh_continuous', enabled); // Persist
                // Loop is always FALSE now to support auto-advance.

                // Refinement: If enabled AND currently playing a 'rust' track (or paused in rest), switch immediately.
                if (enabled && this.hasStartedForWorkout) {
                    const isRestTrack = this.audio.src.includes('/rust/');
                    if (isRestTrack) {
                        console.log("Continuous Mode Enabled during Rest -> Switching to Work Track");
                        this.playNextWorkTrack();
                    }
                }
            }

            togglePlayback() {
                if (this.audio.paused) {
                    this.audio.play().catch(e => console.log("Resume Error", e));
                } else {
                    this.audio.pause();
                }
            }

            playNext() {
                // Determine direction based on current phase?
                // Or simply advance index?
                // If in 'work' phase, we play next work track.
                // If in 'rest' phase, we play next rest track.
                // Both use same playlistIndex.

                this.playlistIndex = this.getEnabledIndex(this.playlistIndex, 1);

                const queue = (this.currentType === 'werk') ? this.workQueue : this.restQueue;
                // Note: currentType is 'werk'/'rust'.

                // Play
                const item = queue[this.playlistIndex];
                this.playSpecificTrack(item, this.currentType);
            }

            playPrevious() {
                let idx = this.playlistIndex;
                const queue = (this.currentType === 'werk') ? this.workQueue : this.restQueue;
                if (queue.length === 0) return;

                // Find previous enabled
                let attempts = 0;
                do {
                    idx = (idx - 1 + queue.length) % queue.length;
                    attempts++;
                    const item = queue[idx];
                    if (this.enabledGenres.has(item.genre)) {
                        this.playlistIndex = idx;
                        break;
                    }
                } while (attempts < queue.length);

                const item = queue[this.playlistIndex];
                this.playSpecificTrack(item, this.currentType);
            }

            fadeOut(durationSeconds) {
                if (!this.audio || this.audio.paused) return;

                // Clear any existing fade
                if (this.fadeInterval) clearInterval(this.fadeInterval);

                const startVolume = this.audio.volume;
                const steps = 20; // updates per second
                const totalSteps = durationSeconds * steps;
                const volumeStep = startVolume / totalSteps;
                let currentStep = 0;

                console.log(`Starting Fade Out over ${durationSeconds}s from ${startVolume}`);

                this.fadeInterval = setInterval(() => {
                    currentStep++;
                    // QUADRATIC / SQUARED FADE (User Request)
                    let linearFactor = (totalSteps - currentStep) / totalSteps;
                    if (linearFactor < 0) linearFactor = 0;

                    let newVol = startVolume * (linearFactor * linearFactor);

                    try {
                        this.audio.volume = newVol;
                    } catch (e) {
                        // ignore rounding errors
                    }

                    if (currentStep >= totalSteps) {
                        clearInterval(this.fadeInterval);
                        this.fadeInterval = null;
                        this.audio.pause();
                        console.log("Fade Out Complete. Audio Paused.");
                    }
                }, 1000 / steps);
            }

            playSpecificTrack(item, type) {
                if (!item) return;
                // Safety check: is genre enabled?
                if (!this.enabledGenres.has(item.genre)) {
                    // Decide behavior: block play?
                    // If user manually clicked a disabled track in playlist?
                    // (They shouldn't see it due to showNowPlaying filter).
                    // If called programmatically?
                    // Safe to block.
                    console.log("Blocked playing disabled genre:", item.genre);
                    return;
                }

                // CANCEL ANY ACTIVE FADE
                if (this.fadeInterval) {
                    clearInterval(this.fadeInterval);
                    this.fadeInterval = null;
                }

                const path = `muziek/${item.genre}/${type}/${item.track}`;
                this.audio.src = path;
                // Maintain current volume based on TYPE
                this.audio.volume = (type === 'werk') ? this.volWork : this.volRest;
                this.audio.play().catch(e => console.log("Manual Play Error", e));
                this.showNowPlaying(item.track, item.genre, type === 'werk' ? 'work' : 'rest');
            }


            updateVolumes(work, rest) {
                this.volWork = work;
                this.volRest = rest;

                // Immediate Effect: Apply volume if currently playing relevant type
                // Note: 'werk' matches 'work' phase, 'rust' matches 'rest' phase
                if (this.audio && !this.audio.paused) {
                    if (this.currentType === 'werk') {
                        this.audio.volume = this.volWork;
                    } else {
                        this.audio.volume = this.volRest;
                    }
                }
            }

            // ... showNowPlaying is separate ...

            playNextWorkTrack() {
                // Deprecated / Mapped to playNext if called by legacy event
                this.playNext();
            }

            setGenres(list) {
                this.selectedGenres = list;
                this.hasStartedForWorkout = false;
            }

            startWorkout() {
                // if (this.selectedGenres.length === 0) return; // Removed to support enable-mid-workout
                this.hasStartedForWorkout = true;
                this.buildPlaylists(); // Build full pool
                this.renderGenreToggles(); // Render UI
                // REMOVED: this.playPhase('rest'); // Don't auto-start. Controller decides.
            }

            buildPlaylists() {
                this.workQueue = [];
                this.restQueue = [];
                // Initialize enabled filters (start inactive if no genres selected, else active)
                this.enabledGenres = new Set(this.selectedGenres);

                // Use ALL available genres for the pool, not just selected ones
                const allGenres = Object.keys(musicManifest);

                // 1. Prepare temp buckets
                const bucketsWork = {};
                const bucketsRest = {};
                let maxLen = 0;

                allGenres.forEach(genre => {
                    bucketsWork[genre] = [];
                    bucketsRest[genre] = [];
                    const db = musicManifest[genre];
                    if (db) {
                        if (db.werk) db.werk.forEach(t => bucketsWork[genre].push({ track: t, genre: genre }));
                        if (db.rust) db.rust.forEach(t => bucketsRest[genre].push({ track: t, genre: genre }));

                        // Shuffle buckets individually so order is random within genre
                        this.shuffle(bucketsWork[genre]);
                        this.shuffle(bucketsRest[genre]);

                        if (bucketsWork[genre].length > maxLen) maxLen = bucketsWork[genre].length;
                    }
                });

                // 2. Interleave (Round Robin)
                for (let i = 0; i < maxLen; i++) {
                    allGenres.forEach(genre => {
                        // Work Track
                        if (bucketsWork[genre] && bucketsWork[genre][i]) {
                            this.workQueue.push(bucketsWork[genre][i]);

                            // Match Rest Track (wrap around if fewer rest tracks)
                            if (bucketsRest[genre] && bucketsRest[genre].length > 0) {
                                const rIndex = i % bucketsRest[genre].length;
                                this.restQueue.push(bucketsRest[genre][rIndex]);
                            } else {
                                // Fallback if no rest tracks for this genre? Should not happen based on manifest, but safety:
                                this.restQueue.push({ track: 'silence.mp3', genre: genre }); // Placeholder
                            }
                        }
                    });
                }

                // 3. Reset Indices
                this.playlistIndex = 0;
                this.justFinishedWork = false;
            }

            // Helper to find next/prev enabled index
            getEnabledIndex(currentIndex, direction) {
                let idx = currentIndex;
                const queue = (this.workQueue.length > 0) ? this.workQueue : [];                // queue is Master Queue. Length should be safe.
                if (queue.length === 0) return 0;

                let attempts = 0;
                do {
                    idx = (idx + direction + queue.length) % queue.length;
                    attempts++;
                    const item = queue[idx];
                    if (this.enabledGenres.has(item.genre)) return idx;
                } while (attempts < queue.length);

                return currentIndex; // No enabled tracks found
            }

            // Check if current index is enabled, if not separate find next
            ensureValidIndex() {
                if (this.workQueue.length === 0) return;
                // Handle safe index wrapper
                this.playlistIndex = (this.playlistIndex || 0) % this.workQueue.length;

                const item = this.workQueue[this.playlistIndex];
                if (!item || !this.enabledGenres.has(item.genre)) {
                    this.playlistIndex = this.getEnabledIndex(this.playlistIndex, 1);
                }
            }

            toggleGenre(genre, isEnabled) {
                if (isEnabled) {
                    this.enabledGenres.add(genre);
                    // Auto-start if it was silenced?
                    if (this.audio.paused && this.hasStartedForWorkout && this.enabledGenres.size > 0) {
                        // Force a "refresh" of the current state
                        const queue = (this.currentType === 'werk') ? this.workQueue : this.restQueue;
                        if (queue.length > 0) {
                            // Try to find a valid track
                            this.ensureValidIndex();
                            const item = queue[this.playlistIndex];
                            // If valid, play
                            if (item && this.enabledGenres.has(item.genre)) {
                                const path = `muziek/${item.genre}/${this.currentType === 'werk' ? 'werk' : 'rust'}/${item.track}`;
                                this.audio.src = path;
                                this.audio.play().catch(e => console.log("Resume play error", e));
                                this.showNowPlaying(item.track, item.genre, this.currentType === 'werk' ? 'work' : 'rest');
                            }
                        }
                    }
                } else {
                    this.enabledGenres.delete(genre);
                    // IMMEDIATE STOP if empty
                    if (this.enabledGenres.size === 0) {
                        this.audio.pause();
                        this.hideNowPlaying();
                        // Allow return, but ensure we save state first!
                    }
                }

                // FIXED: Persist Selection
                this.selectedGenres = Array.from(this.enabledGenres);
                localStorage.setItem('fnh_selected_genres', JSON.stringify(this.selectedGenres));

                if (this.enabledGenres.size === 0) return; // Exit after saving if empty

                this.ensureValidIndex();

                // Refresh Playlist UI if visible
                const nowEl = document.getElementById('gym-now-playing');
                if (nowEl) {
                    const queue = (this.currentType === 'werk') ? this.workQueue : this.restQueue;
                    const item = queue[this.playlistIndex];
                    if (item) this.showNowPlaying(item.track, item.genre, this.currentType === 'werk' ? 'work' : 'rest');
                }
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            stopWorkout() {
                this.audio.pause();
                this.audio.currentTime = 0;
                this.hasStartedForWorkout = false;
                this.hideNowPlaying();
            }

            refillQueue() {
                // No-op in new system, master queue is cyclic
            }

            getNextGenre() {
                return null; // Deprecated
            }

            playPhase(phase) {
                // CANCEL ANY ACTIVE FADE (Fix for Work Music not starting)
                if (this.fadeInterval) {
                    clearInterval(this.fadeInterval);
                    this.fadeInterval = null;
                }

                // if (this.selectedGenres.length === 0) return; // REMOVED!

                // VOLUME LOGIC
                const targetVol = (phase === 'work') ? this.volWork : this.volRest;
                this.audio.volume = targetVol;

                this.currentType = (phase === 'work') ? 'werk' : 'rust';

                // CONTINUOUS MODE
                if (this.continuousMode && !this.audio.paused) {
                    // Start of FIX for "Only Rest Music Playing":
                    // If we are currently playing a 'rust' track but the requested phase is 'work',
                    // we MUST allow the switch to happen, even in continuous mode.
                    const isRestTrack = this.audio.src.includes('/rust/');
                    if (phase === 'work' && isRestTrack) {
                        console.log("Continuous Mode: Switching from Rest to Work track");
                        // Allow fall-through to switch track
                    } else {
                        return; // Logic as before: don't interrupt
                    }
                }

                if (phase === 'work') {
                    // If we just finished a work block (and its following rest), move to next track pair
                    if (this.justFinishedWork) {
                        this.playlistIndex = this.getEnabledIndex(this.playlistIndex, 1);
                    }
                }

                this.ensureValidIndex();

                const queue = (phase === 'work') ? this.workQueue : this.restQueue;
                if (queue.length === 0) return;

                this.playlistIndex = this.playlistIndex % queue.length;
                const item = queue[this.playlistIndex];

                if (!item) return;

                // CRITICAL CHECK: Is this item actually enabled?
                // If ensureValidIndex failed to find an enabled track (e.g. all disabled), it returns current.
                // So we must check again.
                if (!this.enabledGenres.has(item.genre)) {
                    // All genres disabled (or logic issue). Stop/Pause.
                    this.audio.pause();
                    this.hideNowPlaying();
                    // Don't advance state or volume
                    return;
                }

                const path = `muziek/${item.genre}/${phase === 'work' ? 'werk' : 'rust'}/${item.track}`;
                this.audio.src = path;
                this.audio.play().catch(e => console.log("Play Error", e));
                this.showNowPlaying(item.track, item.genre, phase === 'work' ? 'work' : 'rest');

                if (phase === 'work') {
                    this.justFinishedWork = true;
                }
            }

            renderGenreToggles(targetId = null) {
                // Find or create container in audio settings
                let containerId = targetId || 'audio-settings-genres';
                let container = document.getElementById(containerId);

                if (!container && !targetId) {
                    // Create it after volume controls (Default behavior)
                    const parent = document.getElementById('active-volume-panel'); // ... existing creation logic ...
                    // (Simplified for this edit: reuse existing if possible, or fail gracefully if custom ID missing)
                    if (parent) {
                        container = document.createElement('div');
                        container.id = 'audio-settings-genres';
                        container.style.marginTop = "15px";
                        container.style.borderTop = "1px solid rgba(255,255,255,0.1)";
                        container.style.paddingTop = "10px";
                        // Insert before playlist-view if exists
                        const playlist = document.getElementById('playlist-view');
                        if (playlist) parent.insertBefore(container, playlist);
                        else parent.appendChild(container); // Append at end
                    }
                }
                if (!container) return;

                if (!targetId) {
                    container.innerHTML = "<div style='font-size:12px; font-weight:bold; color:#888; margin-bottom:5px;'>GENRES (LIVE)</div>";
                } else {
                    container.innerHTML = ""; // Clear custom container
                }

                // Show ALL manifest genres so user can enable music even if started with none.
                const allGenres = Object.keys(musicManifest);

                allGenres.forEach(genre => {
                    const row = document.createElement('div');
                    row.style.display = "flex";
                    row.style.alignItems = "center";
                    row.style.marginBottom = "5px";

                    const cb = document.createElement('input');
                    cb.type = "checkbox";
                    cb.checked = this.enabledGenres.has(genre);
                    cb.style.marginRight = "8px";
                    cb.style.cursor = "pointer";

                    cb.onchange = (e) => {
                        this.toggleGenre(genre, e.target.checked);
                    };

                    const lbl = document.createElement('span');
                    lbl.innerText = genre;
                    lbl.style.fontSize = "14px";

                    row.appendChild(cb);
                    row.appendChild(lbl);
                    container.appendChild(row);
                });
            }

            showNowPlaying(trackName, genre, type) {
                const nowEl = document.getElementById('gym-now-playing');
                const listEl = document.getElementById('gym-queue-list');

                if (nowEl) {
                    const cleanTitle = trackName.replace('.mp3', '');
                    nowEl.innerText = `🎵 ${genre} - ${cleanTitle} (${type})`;
                }

                if (listEl) {
                    listEl.innerHTML = "";
                    const queue = (type === 'work' || type === 'work') ? this.workQueue : this.restQueue;
                    // Note: 'werk' vs 'work' consistency fix handled by '||' logic usually, 
                    // but here passed 'type' comes from call.
                    // playPhase sends 'work'/'rest'.

                    let displayIndex = 1;

                    queue.forEach((item, i) => {
                        // FILTER: Only show enabled genres
                        if (!this.enabledGenres.has(item.genre)) return;

                        const div = document.createElement('div');
                        div.style.padding = "4px 8px";
                        div.style.borderBottom = "1px solid rgba(255,255,255,0.05)";
                        div.style.cursor = "pointer";
                        div.className = "playlist-item";

                        const cleanTrack = item.track.replace('.mp3', '');

                        if (i === this.playlistIndex) {
                            div.style.color = "#30D158";
                            div.style.fontWeight = "bold";
                            div.innerText = `▶ ${cleanTrack} (${item.genre})`;
                        } else {
                            div.style.color = "#aaa";
                            div.innerText = `${displayIndex}. ${cleanTrack} (${item.genre})`;
                        }
                        displayIndex++;

                        div.onclick = () => {
                            this.playlistIndex = i;
                            this.playSpecificTrack(item, (type === 'work' || type === 'work') ? 'werk' : 'rust');
                            // Note: playSpecificTrack is legacy. Ideally should call playPhase-like logic?
                            // But playSpecificTrack is: audio.src = ...
                            // We should maintain it or update it.
                            // See logic below.
                        };

                        listEl.appendChild(div);
                    });
                }
            }

            hideNowPlaying() {
                const txt = document.getElementById('gym-now-playing');
                if (txt) txt.innerHTML = "";

                const list = document.getElementById('gym-queue-list');
                if (list) list.innerHTML = "";
            }
        }

        const bgMusicManager = new BackgroundMusicManager();

        window.addEventListener('load', function () {
            populateLiveCoachSelect(); // Ensure Select is ready for Save ops
            // renderMusicGenres(); // Removed (Old UI)
            // Ensure Audio Mode UI matches state
            updateLiveAudioUI();
        });

        function renderMusicGenres() {
            const container = document.getElementById('music-genres-container');
            if (!container) return;
            container.innerHTML = "";

            const genres = Object.keys(musicManifest);

            if (genres.length === 0) {
                container.innerHTML = "<div style='color:#666; font-size:12px;'>Geen muziek gevonden</div>";
                return;
            }

            genres.forEach(genre => {
                const div = document.createElement('div');
                div.className = 'gen-checkbox-item';
                div.innerHTML = `
                    <input type="checkbox" value="${genre}" class="music-genre-check" id="chk-genre-${genre}">
                    <label for="chk-genre-${genre}" style="cursor:pointer; color:#ccc; margin:0; text-transform:none;">${genre}</label>
                `;
                div.onclick = (e) => {
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'LABEL') {
                        const cb = div.querySelector('input');
                        cb.checked = !cb.checked;
                    }
                };
                container.appendChild(div);
            });
        }

        function getSelectedGenres() {
            const checks = document.querySelectorAll('.music-genre-check:checked');
            return Array.from(checks).map(c => c.value);
        }




        // Global Audio State (Priority System)
        let currentActiveSource = null;

        let currentAudioPriority = 0; // 0=Idle, 1=Low, 2=High

        function playMp3WebAudio(url, key, priority = 1) {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Check Cache
            if (audioCache[url]) {
                logAudioDebug(`✅ WebAudio Cache: ${key} (P${priority})`);
                playBuffer(audioCache[url], priority, key);
                return;
            }

            // Fetch
            fetch(url)
                .then(response => {
                    if (!response.ok) throw new Error("404");
                    return response.arrayBuffer();
                })
                .then(arrayBuffer => audioCtx.decodeAudioData(arrayBuffer))
                .then(audioBuffer => {
                    audioCache[url] = audioBuffer;
                    logAudioDebug(`✅ WebAudio Play: ${key} (P${priority})`);
                    playBuffer(audioBuffer, priority, key);
                })
                .catch(e => {
                    failedAudioKeys.add(key);
                    logAudioDebug(`❌ WebAudio Fail: ${key}`);
                    console.error("WebAudio Error", e);
                });
        }

        function playBuffer(buffer, priority, key = "") {
            // STOP previous active sound if it exists
            if (currentActiveSource) {
                // EXCEPTION: Allow "Work Start" (P2) to overlap "Countdown" (P2)
                // This fixes the issue where "1" is cut off by "GO!"
                const curKey = currentActiveSource.customKey || "";
                const newKey = key || "";

                const isWorkStart = newKey.includes('work_start');
                // Cover common countdown keys: 'prep_countdown', 'count', '3', '2', '1'
                const isCountdown = curKey.includes('count') || curKey.includes('down') || ['1', '2', '3'].includes(curKey);

                const shouldOverlap = (isWorkStart && isCountdown);

                if (!shouldOverlap) {
                    logAudioDebug(`🛑 Stopping ${curKey} for ${newKey}`);
                    try {
                        currentActiveSource.stop();
                        currentActiveSource = null;
                    } catch (e) { console.log("Stop error", e); }
                } else {
                    logAudioDebug(`🔀 Mixing: ${curKey} + ${newKey}`);
                }
            }

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.customKey = key; // Store for next comparison

            // VOLUME BOOST (for Mix Mode) - Adjusted by Coach Volume Slider
            const gainNode = audioCtx.createGain();
            // Base boost was 2.5. Multiply by coach volume (0.0 - 1.0)
            const coachVolInput = document.getElementById('vol-coach-live');
            const coachVol = coachVolInput ? parseFloat(coachVolInput.value) : parseFloat(localStorage.getItem('fnh_vol_coach') || 1.0);
            gainNode.gain.value = 2.5 * coachVol;

            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            // Update State
            // Only update "Current Active" if we stopped the old one OR if it's a new dominant sound?
            // If we are mixing, we have TWO sources.
            // If we replace the pointer `currentActiveSource` with the new one, the old one just plays out (Good).
            // But if the old one ends cleanly, its onended might clear the NEW one's priority if we are not careful?
            // Logic below handles this: `if (currentActiveSource === source)`
            // Since we update `currentActiveSource` to the NEW source, the old source's onended will see mismatch and do nothing.
            // Perfect.

            currentActiveSource = source;
            currentAudioPriority = priority;

            source.onended = function () {
                // Only reset if THIS was the active source
                if (currentActiveSource === source) {
                    currentAudioPriority = 0;
                    currentActiveSource = null;
                }
            };

            source.start(0);
        }

        function addBonusStep(r, label, time, rest, bId) {
            schedule.push({
                type: 'work',
                time: time,
                initialTime: time,
                label: label,
                info: { round: r, exercise: 0, set: 0, globalSet: 0, bonusId: bId } // 0 indicates bonus
            });
            schedule.push({
                type: 'rest-exercise',
                time: rest,
                initialTime: rest,
                label: "WISSEL",
                info: { round: r, exercise: 0, set: 0, text: "Klaarmaken..." }
            });
        }

        function renderPreviewList() {
            const list = document.getElementById('preview-list'); list.innerHTML = ""; let runningDate = new Date();
            schedule.forEach((item) => {
                if (item.type === 'finish') return;
                let timeStr = runningDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                runningDate.setSeconds(runningDate.getSeconds() + item.time);
                const div = document.createElement('div'); div.className = `schedule-item`;
                let icon = ""; if (item.type === 'rest-long') { div.style.borderLeft = "4px solid #0A84FF"; icon = '☕'; } else if (item.type === 'rest-exercise') { div.style.borderLeft = "4px solid #BF5AF2"; icon = '🔀'; } else if (item.type === 'work') icon = '🔥'; else if (item.type === 'rest') icon = '💤'; else icon = '🚀';
                let desc = item.label; if (item.info && item.info.round && item.info.exercise > 0) desc += ` (R${item.info.round}/E${item.info.exercise}/S${item.info.set})`;
                div.innerHTML = `<div class="col-time">${timeStr}</div><div class="col-desc">${icon} ${desc}</div><div class="col-dur">${item.time}s</div>`;
                list.appendChild(div);
            });
        }

        function triggerAudio(key, fallbackText, extraInfo = "") {
            try {
                if (audioMode === 'beep') {
                    if (key.includes('work')) playBeep(800, 'start');
                    else if (key.includes('rest')) playBeep(400, 'end');
                    else if (key === 'tick') playBeep(600, 'tick');
                    else if (key === 'finish') playBeep(1000, 'win');
                    else if (key === 'prep_countdown') {
                        // 3 beeps for 3-2-1
                        playBeep(600, 'tick');
                        setTimeout(() => playBeep(600, 'tick'), 1000);
                        setTimeout(() => playBeep(600, 'tick'), 2000);
                    }
                    return;
                }

                // MP3 Support Logic
                const coachId = document.getElementById('coach-preset-live') ? document.getElementById('coach-preset-live').value : 'eva'; // UPDATED


                // Check Enable/Disable Toggle
                if (speechSettings[key] && speechSettings[key].enabled === false) {
                    logAudioDebug(`🔇 Silenced by user setting: ${key}`);
                    return;
                }

                if (coachId && coachId !== 'loading' && !failedAudioKeys.has(key)) {
                    let finalKey = key;

                    // Retrieve variants config for this coach
                    const preset = coachPresets[coachId];
                    const variantsMap = preset ? (preset.variants || {}) : {};

                    // --- VARIANT LOGIC ---
                    if (variantsMap[key] && variantsMap[key] >= 1) {
                        const count = variantsMap[key];
                        // Initialize playlist if needed
                        if (!audioPlaylists[key]) {
                            const arr = Array.from({ length: count }, (_, i) => i + 1);
                            // Fisher-Yates Shuffle
                            for (let i = arr.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [arr[i], arr[j]] = [arr[j], arr[i]];
                            }
                            audioPlaylists[key] = { tracks: arr, ptr: 0 };
                        }
                        const pl = audioPlaylists[key];
                        const variantId = pl.tracks[pl.ptr];
                        pl.ptr = (pl.ptr + 1) % pl.tracks.length;
                        finalKey = `${key}_${variantId}`;
                    }

                    logAudioDebug(`🎵 Attempting MP3: ${coachId}/${finalKey}.mp3`);
                    const mp3Path = `coaches/${coachId}/${finalKey}.mp3`;

                    // ALWAYS USE WEB AUDIO MIX MODE (Better Priority & Overlap Handling)
                    // Priority Mapping
                    let priority = 1; // Default: Low
                    const highPriorityKeys = [
                        'work_start', 'rest_start', 'rest_set_start',
                        'rest_switch_start', 'rest_round_start',
                        'prep_countdown', 'finish',
                        'work_start_lastround',
                        'manual_override', 'work_complete', 'rest_complete',
                        'tick'
                    ];

                    // Check Priority
                    if (highPriorityKeys.includes(key) || key.includes('work_start') || key.includes('count') || ['1', '2', '3'].includes(key)) {
                        priority = 2;
                    }

                    // PRIORITY RULE:
                    // If P2 comes in -> Stop everything (handled in playBuffer) and Play.
                    // If P1 comes in -> ONLY play if current is 0. If current is 2, IGNORE P1.
                    if (priority === 1 && currentAudioPriority === 2) {
                        logAudioDebug(`🚫 Skipped Low Priority: ${key} (Busy w/ High)`);
                        return;
                    }

                    playMp3WebAudio(mp3Path, key, priority);
                    return;
                }

                // Standard HTML5 Audio (Single Global Object)
                globalCoachAudio.src = mp3Path;
                const playPromise = globalCoachAudio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => { logAudioDebug(`✅ Playing MP3: ${key}`); })
                        .catch(error => {
                            failedAudioKeys.add(key);
                            logAudioDebug(`❌ MP3 Failed: ${key}`);
                        });
                }
                return;
                return;
            } catch (e) {
                console.error("Audio Trigger Error", e);
                logAudioDebug(`⚠️ Audio Error: ${e.message}`);
            }
        }

        function testMixModeSound() {
            logAudioDebug("🔊 Sound Check Triggered");

            // Replicate triggerAudio logic regarding Mix Mode
            if (iosMixMode) {
                playMp3WebAudio('sound_check.mp3', 'sound_check', 2);
            } else {
                globalCoachAudio.src = 'sound_check.mp3';
                globalCoachAudio.play()
                    .then(() => logAudioDebug("✅ Standard Audio Check"))
                    .catch(e => logAudioDebug("❌ Standard Audio Fail: " + e.message));
            }
        }

        function logAudioDebug(msg) {
            const loginfo = document.getElementById('audio-debug-log');
            if (loginfo) {
                const line = document.createElement('div');
                const time = new Date().toLocaleTimeString('nl-NL', { hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit" });
                line.innerText = `[${time}] ${msg}`;
                loginfo.prepend(line);
                // Keep only last 20 lines
                while (loginfo.children.length > 20) {
                    loginfo.removeChild(loginfo.lastChild);
                }
            }
        }

        function playBeep(f, t) { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); const o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination); o.frequency.value = f; o.type = 'sine'; const n = audioCtx.currentTime; if (t === 'tick') { g.gain.setValueAtTime(0.1, n); o.start(n); o.stop(n + 0.1); } else if (t === 'win') { g.gain.setValueAtTime(0.1, n); o.start(n); o.stop(n + 0.2); setTimeout(() => playBeep(1200, 'tick'), 300); } else { g.gain.setValueAtTime(0.3, n); o.start(n); o.stop(n + 0.5); } }

        let preWorkoutInterval = null;

        function startWorkout() {
            // Audio Context for Beep Mode (Ensure resumed)
            if (audioMode === 'beep') { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); audioCtx.resume(); }

            const startStr = document.getElementById('startTimeValue').value;
            if (startStr) {
                const now = new Date();
                const [h, m] = startStr.split(':');
                const targetStart = new Date();
                targetStart.setHours(h, m, 0, 0);

                // FIX: If time is in the past, treat as "Next Day" (Wrap 24h)
                // User requested: "Countdown to tomorrow" instead of immediate start
                if (targetStart <= now) {
                    targetStart.setDate(targetStart.getDate() + 1);
                }

                if (targetStart > now) {
                    // Show Countdown Overlay
                    const overlay = document.getElementById('pre-workout-overlay');
                    const timerEl = document.getElementById('pre-workout-timer');
                    const startInfoEl = document.getElementById('pre-workout-start-time'); // NEW

                    overlay.style.display = 'flex';
                    if (startInfoEl) startInfoEl.innerText = `STARTTIJD: ${startStr}`;

                    // AUDIO CONTROLS INIT (PRE-WORKOUT)
                    const volWorkPre = document.getElementById('vol-music-pre');
                    const volRestPre = document.getElementById('vol-rest-pre');
                    const valVolWorkPre = document.getElementById('val-vol-work-pre');
                    const valVolRestPre = document.getElementById('val-vol-rest-pre');
                    const chkContPre = document.getElementById('chk-continuous-pre');

                    // Sync with current Manager state
                    if (volWorkPre) {
                        volWorkPre.value = bgMusicManager.volWork;
                        valVolWorkPre.innerText = Math.round(bgMusicManager.volWork * 100) + "%";
                        volWorkPre.oninput = (e) => {
                            const v = parseFloat(e.target.value);
                            bgMusicManager.volWork = v;
                            valVolWorkPre.innerText = Math.round(v * 100) + "%";
                            // If playing work, update live
                            if (bgMusicManager.currentType === 'werk') bgMusicManager.audio.volume = v;
                            // Also sync main settings
                            const main = document.getElementById('vol-music-live'); if (main) main.value = v;
                            localStorage.setItem('fnh_vol_music', v);
                        };
                    }
                    if (volRestPre) {
                        volRestPre.value = bgMusicManager.volRest;
                        valVolRestPre.innerText = Math.round(bgMusicManager.volRest * 100) + "%";
                        volRestPre.oninput = (e) => {
                            const v = parseFloat(e.target.value);
                            bgMusicManager.volRest = v;
                            valVolRestPre.innerText = Math.round(v * 100) + "%";
                            // If playing rest, update live
                            if (bgMusicManager.currentType === 'rust') bgMusicManager.audio.volume = v;
                            // Also sync main settings
                            const main = document.getElementById('vol-music-rest-live'); if (main) main.value = v;
                            localStorage.setItem('fnh_vol_music_rest', v);
                        };
                    }
                    if (chkContPre) {
                        chkContPre.checked = bgMusicManager.continuousMode;
                        chkContPre.onchange = (e) => {
                            bgMusicManager.setContinuous(e.target.checked);
                            // Sync main
                            const main = document.getElementById('chk-music-continuous'); if (main) main.checked = e.target.checked;

                            // Live Switch Logic for Countdown
                            if (e.target.checked) {
                                // Switched ON -> Play Work Music immediately
                                bgMusicManager.playPhase('work');
                            } else {
                                // Switched OFF -> Play Rest Music immediately
                                bgMusicManager.playPhase('rest');
                            }
                        };
                    }

                    // MUSIC START (Immediate)
                    // Ensure Manager is initialized (builds playlists -> syncs enabledGenres) BEFORE rendering UI
                    if (!bgMusicManager.hasStartedForWorkout) {
                        bgMusicManager.startWorkout();
                    }

                    // Render Genres (Now using fresh enabledGenres)
                    bgMusicManager.renderGenreToggles('pre-workout-genres');

                    // LPOGIC: If Continuous Mode, Play Work Music NOW
                    if (bgMusicManager.continuousMode) {
                        bgMusicManager.playPhase('work');
                    } else {
                        bgMusicManager.playPhase('rest');
                    }

                    // Initial wake lock attempt (user interaction context)
                    if ('wakeLock' in navigator) navigator.wakeLock.request('screen').catch(console.log);

                    clearInterval(preWorkoutInterval);

                    const updateTimer = () => {
                        const currentNow = new Date();
                        const diffMs = targetStart - currentNow;

                        if (diffMs <= 0) {
                            clearInterval(preWorkoutInterval);
                            overlay.style.display = 'none';
                            performStart();
                            return;
                        }

                        // Format MM:SS
                        const totalSec = Math.ceil(diffMs / 1000);
                        const mins = Math.floor(totalSec / 60);
                        const secs = totalSec % 60;
                        timerEl.innerText = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                    };

                    updateTimer(); // Immediate update
                    preWorkoutInterval = setInterval(updateTimer, 1000);
                    return;
                }
            }
            // No delay needed
            performStart();
        }

        function performStart() {
            // Hide overlay if manual skip was triggered
            document.getElementById('pre-workout-overlay').style.display = 'none';
            if (preWorkoutInterval) clearInterval(preWorkoutInterval);
            if ('wakeLock' in navigator) navigator.wakeLock.request('screen').catch(console.log);
            if (audioMode === 'beep') { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume(); } else { if (window.speechSynthesis) window.speechSynthesis.cancel(); }

            window.lastStepChangeTime = Date.now(); // SAFETY: Set anchor on actual start
            clearInterval(timerInterval); // Ensure no previous timer is running

            // LOGGING START
            try {
                logWorkoutToSheet();
            } catch (err) {
                console.log("Logging failed", err);
            }

            // Ensure times are fresh
            // FIX: Force Start Time Input to NOW. performStart() means we are starting immediately.
            // This ensures calculateRealTime() sees the correct "Now" time vs End Time.
            const now = new Date();
            document.getElementById('startTimeValue').value = now.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });

            calculateRealTime();
            generateScheduleData(true);
            populateJumpMenus();

            document.getElementById('setup-screen').classList.add('hidden');
            // Scroll Fix v1.9: Use block display for reliable scrolling
            // Reset style completely to remove !important inline hider
            const ts = document.getElementById('timer-screen');
            ts.style.cssText = '';
            ts.style.display = 'block';

            workoutStartTime = new Date();
            const [h, m] = document.getElementById('endTimeValue').value.split(':');
            targetEndTimeDate = new Date(); targetEndTimeDate.setHours(h, m, 0, 0);
            if (targetEndTimeDate < workoutStartTime) targetEndTimeDate.setDate(targetEndTimeDate.getDate() + 1);

            updateEndTimeDisplay();
            currentIndex = 0;
            audioPlaylists = {}; // Reset Shuffle Queues
            failedAudioKeys.clear(); // Reset MP3 failures on new workout start
            milestonesTriggered = { m25: false, m50: false, m75: false }; // Reset milestones
            stepEndTime = Date.now() + (schedule[0].time * 1000);

            // NEW: Render Live Schedule
            renderLiveSchedule();

            // MUSIC START
            // bgMusicManager.setGenres(getSelectedGenres()); // REMOVED: Respect persistent state
            // Only start if not already started (e.g. by overlay)
            if (!bgMusicManager.hasStartedForWorkout) {
                bgMusicManager.startWorkout();
            }

            runStep();
        }

        function populateJumpMenus() {
            const rounds = parseInt(document.getElementById('rounds').value); const ex = parseInt(document.getElementById('exercises').value); const sets = parseInt(document.getElementById('sets').value);
            const rSel = document.getElementById('jump-round'); const eSel = document.getElementById('jump-exercise'); const sSel = document.getElementById('jump-set');
            rSel.innerHTML = ""; eSel.innerHTML = ""; sSel.innerHTML = "";
            for (let i = 1; i <= rounds; i++) { const opt = document.createElement('option'); opt.value = i; opt.text = "Ronde " + i; rSel.appendChild(opt); }
            for (let i = 1; i <= ex; i++) { const opt = document.createElement('option'); opt.value = i; opt.text = "Oef " + i; eSel.appendChild(opt); }
            for (let i = 1; i <= sets; i++) { const opt = document.createElement('option'); opt.value = i; opt.text = "Set " + i; sSel.appendChild(opt); }
        }

        function handleJump() {
            const r = parseInt(document.getElementById('jump-round').value); const e = parseInt(document.getElementById('jump-exercise').value); const s = parseInt(document.getElementById('jump-set').value);
            const newIndex = schedule.findIndex(step => { return step.type === 'work' && step.info && step.info.round === r && step.info.exercise === e && step.info.set === s; });
            if (newIndex > -1) {
                // FIXED: Use same logic as Schedule List Click (Popup for Skip/Adjust)
                jumpToStep(newIndex);
            }
        }

        function runStep() {
            if (currentIndex >= schedule.length) return;
            try {
                const step = schedule[currentIndex];
                const nextStep = schedule[currentIndex + 1];
                const totalRounds = parseInt(document.getElementById('rounds').value);
                const totalEx = document.getElementById('exercises').value;

                const body = document.body; body.className = '';
                const titleEl = document.getElementById('gym-phase-title'); const nextEl = document.getElementById('gym-next-info');

                // MUSIC UPDATE
                if (step.type === 'finish') {
                    bgMusicManager.stopWorkout();
                } else if (step.type === 'work') {
                    bgMusicManager.playPhase('work');
                } else {
                    bgMusicManager.playPhase('rest');
                }

                if (step.info && step.info.maxRounds) {
                    document.getElementById('val-round').innerText = `${step.info.round}/${step.info.maxRounds}`;
                    // Only show exercise/set if not 0 (extra phase)
                    if (step.info.exercise > 0) {
                        document.getElementById('val-exercise').innerText = `${step.info.exercise}/${step.info.maxEx}`;
                        document.getElementById('val-set').innerText = `${step.info.set}/${step.info.maxSets}`;
                        document.getElementById('jump-round').value = step.info.round; document.getElementById('jump-exercise').value = step.info.exercise; document.getElementById('jump-set').value = step.info.set;
                    } else {
                        document.getElementById('val-exercise').innerText = "-";
                        document.getElementById('val-set').innerText = "-";
                    }
                    document.getElementById('gym-stats-container').style.opacity = 1;
                } else { document.getElementById('gym-stats-container').style.opacity = 0.5; }

                // NEW: Update Live Schedule Highlight
                updateLiveScheduleHighlight();

                // Dynamic Inner Ring Color (based on NEXT step)
                let nextColor = '#30D158'; // Default Green (Work)
                let nextGlow = 'rgba(48, 209, 88, 0.6)';
                if (nextStep) {
                    if (nextStep.type === 'work') { nextColor = '#30D158'; nextGlow = 'rgba(48, 209, 88, 0.6)'; }
                    else if (nextStep.type === 'rest') { nextColor = '#FF9F0A'; nextGlow = 'rgba(255, 159, 10, 0.6)'; }
                    else if (nextStep.type === 'rest-exercise') { nextColor = '#BF5AF2'; nextGlow = 'rgba(191, 90, 242, 0.6)'; }
                    else if (nextStep.type === 'rest-long') { nextColor = '#0A84FF'; nextGlow = 'rgba(10, 132, 255, 0.6)'; }
                    else if (nextStep.type === 'finish') { nextColor = '#FFD60A'; nextGlow = 'rgba(255, 214, 10, 0.6)'; }
                    else if (nextStep.type === 'prep') { nextColor = '#3a3a3c'; nextGlow = 'rgba(58, 58, 60, 0.6)'; }
                } else {
                    nextColor = '#FFD60A'; nextGlow = 'rgba(255, 214, 10, 0.6)';
                }

                // Current Color Logic for Background (Smooth Transition)
                let currentColor = '#000000';
                if (step.type === 'work') currentColor = '#30D158';
                else if (step.type === 'rest') currentColor = '#FF9F0A';
                else if (step.type === 'rest-exercise') currentColor = '#BF5AF2';
                else if (step.type === 'rest-long') currentColor = '#0A84FF';
                else if (step.type === 'prep') currentColor = '#3a3a3c';

                const hgBg = document.getElementById('hourglass-bg');
                if (hgBg) {
                    hgBg.style.backgroundColor = currentColor;
                }

                // ANCHOR FOR PROGRESS BAR (SAFE MODE)
                window.lastStepChangeTime = Date.now();

                const ringStep = document.getElementById('ring-step');
                if (ringStep) {
                    ringStep.style.stroke = "#ffffff"; // Always White
                    ringStep.style.filter = `drop-shadow(0 0 10px rgba(255,255,255,0.4))`;
                }

                titleEl.innerText = step.label;
                titleEl.className = 'gym-phase-title';
                if (step.label === 'WERKEN' || step.label === 'RUST' || step.type === 'work') {
                    // Dynamic Sizing based on character count
                    if (step.label.length > 20) {
                        titleEl.classList.add('long-text');
                    } else if (step.label.length < 10) {
                        titleEl.classList.add('huge-text');
                    }
                    // Else: Normal (8vw)
                }

                let nextText = "Hierna: Klaar";
                if (nextStep) { nextText = "Hierna: " + nextStep.label; if (nextStep.type === 'work' && nextStep.info && nextStep.info.exercise > 0) nextText += ` (Oef ${nextStep.info.exercise})`; }
                nextEl.innerText = nextText;

                // Set Hourglass Color immediately at start of step
                const hgFill = document.getElementById('hourglass-fill');
                if (hgFill) {
                    hgFill.style.backgroundColor = nextColor;
                    // INSTANT RESET: Disable transition to prevent "falling" look
                    hgFill.style.transition = 'none';
                    hgFill.style.height = "0%";
                    // Force reflow
                    hgFill.offsetHeight;
                    // Restore transition (needs to match CSS: height 1s linear, background-color 0.5s ease)
                    hgFill.style.transition = 'height 1s linear, background-color 0.5s ease';
                }

                if (!step.hasPlayedEntry) {
                    step.hasPlayedEntry = true;
                    if (step.type === 'work') {
                        body.classList.add('mode-work');
                        // Standard work audio triggers
                        if (step.info.exercise > 0 || step.info.bonusId) {
                            // ALWAYS trigger "Start" (High Priority)
                            // NEW: Check for First Set of Last Exercise (Last Round only? User said "Laatste Oefening" replacing "Laatste Ronde")
                            // Assuming Last Round -> Last Exercise -> Set 1.
                            if (step.info.round === step.info.maxRounds && step.info.exercise === step.info.maxEx && step.info.set === 1) {
                                triggerAudio('work_start_lastround', "Start laatste oefening");
                            } else {
                                triggerAudio('work_start', "Start");
                            }

                            // Removed mile_lastround logic per request
                        }
                    }
                    else if (step.type === 'rest') {
                        body.classList.add('mode-rest');
                        let info = ""; if (speechSettings.rest_set_tips && speechSettings.rest_set_tips.enabled) { const tips = ["Adem in, adem uit", "Schud je spieren los", "Slokje water", "Blijf gefocust"]; info = tips[Math.floor(Math.random() * tips.length)]; }
                        triggerAudio('rest_set_start', "Rust", info);
                    }
                    else if (step.type === 'rest-exercise') {
                        body.classList.add('mode-switch');
                        let info = ""; if (speechSettings.rest_switch_info && speechSettings.rest_switch_info.enabled && nextStep && nextStep.info && nextStep.info.exercise > 0) { info = `Hierna oefening ${nextStep.info.exercise} van de ${totalEx}`; }
                        triggerAudio('rest_switch_start', "Wissel", info);
                    }
                    else if (step.type === 'rest-long') {
                        body.classList.add('mode-long');
                        let info = ""; if (speechSettings.rest_round_info && speechSettings.rest_round_info.enabled && nextStep && nextStep.info) { info = `Hierna ronde ${nextStep.info.round} van de ${totalRounds}`; }
                        triggerAudio('rest_round_start', "Grote pauze", info);
                    }
                    else if (step.type === 'prep') { body.classList.add('mode-prep'); triggerAudio('prep_intro', "Welkom"); }
                    else { finish(); return; }
                } else {
                    // Ensure class is correct valid even if we didn't play audio
                    if (step.type === 'work') body.classList.add('mode-work');
                    else if (step.type === 'rest') body.classList.add('mode-rest');
                    else if (step.type === 'rest-exercise') body.classList.add('mode-switch');
                    else if (step.type === 'rest-long') body.classList.add('mode-long');
                    else if (step.type === 'prep') body.classList.add('mode-prep');
                }

                stepEndTime = Date.now() + (step.time * 1000);
                document.getElementById('countdown').innerText = step.time;

                clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    if (!isPaused) {
                        const now = Date.now();
                        const remainingMs = stepEndTime - now;
                        let remainingSec = Math.ceil(remainingMs / 1000);

                        // HOURGLASS ANIMATION
                        if (hgFill) {
                            const totalDurMs = step.initialTime * 1000;
                            if (totalDurMs > 0) {
                                let pct = 100 - ((remainingMs / totalDurMs) * 100);
                                if (pct < 0) pct = 0;
                                if (pct > 100) pct = 100;
                                hgFill.style.height = pct + "%";
                            }
                        }

                        if (remainingSec < 0) {
                            while (remainingSec < 0) {
                                currentIndex++; if (currentIndex >= schedule.length) { finish(); return; }
                                const skippedStep = schedule[currentIndex];
                                stepEndTime += (skippedStep.time * 1000);
                                remainingSec = Math.ceil((stepEndTime - Date.now()) / 1000);
                            }
                            runStep(); return;
                        }

                        step.time = remainingSec;
                        document.getElementById('countdown').innerText = step.time;

                        // REAL TIME SYNC ENGINE:
                        // 1. Verify/Update Schedule & Get Authoritative End Time
                        const rtcEndTime = renderLiveSchedule();

                        // 2. Sync Global End Time & Display
                        if (rtcEndTime && !isNaN(rtcEndTime.getTime())) {
                            targetEndTimeDate = rtcEndTime;
                            updateEndTimeDisplay(); // Keep text synced
                        }

                        // 3. Update Rings using the synced time
                        updateProgressRings(step.time, step.initialTime);

                        const totalDiff = targetEndTimeDate - now;
                        if (totalDiff > 0) {
                            const m = Math.floor(totalDiff / 60000); const s = Math.floor((totalDiff % 60000) / 1000);
                            const circleRem = document.getElementById('circle-remaining');
                            if (circleRem) circleRem.innerText = `${m}m ${s}s`;
                        } else {
                            const circleRem = document.getElementById('circle-remaining');
                            if (circleRem) circleRem.innerText = "0m 0s";
                        }

                        const init = step.initialTime;
                        if (step.type === 'work') {
                            let audioTriggered = false;
                            if (step.time === Math.floor(init / 2) && init >= 20) {
                                triggerAudio('work_halfway', "Halverwege");
                                audioTriggered = true;
                            }
                            if (!audioTriggered && step.time === 30 && init > 40) {
                                triggerAudio('work_30s', "30 seconden");
                                audioTriggered = true;
                            }
                            if (!audioTriggered && step.time === 10 && init > 20) {
                                triggerAudio('work_10s', "10 seconden");
                            }
                        }
                        if (step.type === 'rest-long' && step.time === 15 && init > 20) triggerAudio('rest_round_15s', "Nog 15 seconden, ga naar je oefening");
                        if (step.type === 'rest-exercise' && step.time === 10 && init > 15) triggerAudio('rest_switch_10s', "Nog 10 seconden");

                        if (step.time <= 0) { clearInterval(timerInterval); currentIndex++; runStep(); }
                        else if (step.time <= 5) {
                            // FADE OUT REST MUSIC (User Request: Start at 5s, End at 1s -> 4s duration)
                            // This ensures the last second ("1") is completely silent.
                            if (step.time === 5 && (step.type === 'rest' || step.type === 'rest-exercise' || step.type === 'rest-long' || step.type === 'prep')) {
                                bgMusicManager.fadeOut(4);
                            }

                            // COUNTDOWN AUDIO (Still starts at 3s)
                            if (step.time <= 3) {
                                if (speechSettings.use_mp3) {
                                    // MP3 Mode: Trigger prep_countdown once at 3s. Silence at 2s/1s.
                                    if (step.time === 3) triggerAudio('prep_countdown', "3 2 1");
                                } else {
                                    // TTS Mode: Individual ticks
                                    triggerAudio('tick', step.time.toString());
                                }
                            }
                        }
                    } else {
                        // Do nothing while paused
                    }
                }, 1000);
            } catch (e) {
                console.error("CRITICAL ERROR IN RUNSTEP:", e);
                alert("Fout in timer: " + e.message + "\n\nMaak een screenshot en stuur dit door!");
            }
        }

        function triggerEndTimeEdit() {
            const timeStr = targetEndTimeDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
            const input = document.getElementById('hidden-endtime-input'); input.value = timeStr;
            if ('showPicker' in HTMLInputElement.prototype) { try { input.showPicker(); } catch (e) { input.click(); } } else { input.click(); }
        }

        function handleNewEndTime(newVal) {
            if (!newVal) return;
            const [h, m] = newVal.split(':'); const newDate = new Date(); newDate.setHours(h, m, 0, 0);
            const now = new Date();
            if (newDate < now) { if (newDate.getTime() < now.getTime() - 12 * 3600 * 1000) { newDate.setDate(newDate.getDate() + 1); } }

            targetEndTimeDate = newDate;
            updateEndTimeDisplay(); recalculateForFixedEnd();
            renderLiveSchedule(); // Re-render to show updated times if needed
            triggerAudio('manual_override', "Eindtijd aangepast, schema herberekend");
        }

        function recalculateForFixedEnd() {
            const now = new Date();
            const secsRemaining = Math.floor((targetEndTimeDate - now) / 1000);
            let workStepsLeft = 0; let fixedRest = 0;
            for (let i = currentIndex; i < schedule.length; i++) {
                if (schedule[i].type === 'finish') continue;
                if (schedule[i].type.includes('rest')) fixedRest += schedule[i].time;
                else if (schedule[i].type === 'work') {
                    // Check if it's a regular exercise or extra start
                    // We only adjust regular exercises.
                    // Extra start is considered fixed time (like rest).
                    if (schedule[i].info && schedule[i].info.exercise > 0) {
                        workStepsLeft++;
                    } else {
                        fixedRest += schedule[i].time; // Treat extra work as fixed rest time for calc purposes
                    }
                }
                else if (schedule[i].type === 'prep') workStepsLeft++; // Prep usually 10s fixed, but kept logic same
            }

            if (workStepsLeft > 0) {
                const availableForWork = secsRemaining - fixedRest;
                let newWork = Math.floor(availableForWork / workStepsLeft);
                if (newWork < 5) newWork = 5;

                const currentIsWork = (schedule[currentIndex].type === 'work' && schedule[currentIndex].info.exercise > 0);
                const oldWorkVal = schedule[currentIndex].initialTime;

                for (let i = currentIndex; i < schedule.length; i++) {
                    if (schedule[i].type === 'work' && schedule[i].info.exercise > 0) {
                        schedule[i].time = newWork; schedule[i].initialTime = newWork;
                    }
                }
                if (currentIsWork) {
                    const diff = newWork - oldWorkVal;
                    stepEndTime += (diff * 1000);
                    document.getElementById('countdown').innerText = Math.ceil((stepEndTime - Date.now()) / 1000);
                }
            }
        }

        function handlePauseClick() {
            const btn = document.getElementById('btn-pause');

            // Toggle state? 
            // Current flow: Pause -> Menu. Resume is handled by Menu buttons.
            // If we are already paused and menu is closed (e.g. via Cancel), clicking Play opens menu again.

            if (!isPaused) {
                isPaused = true;
                pauseStartTime = Date.now();
                if (btn) btn.innerText = "▶️";
                document.body.classList.add('mode-pause');
                const titleEl = document.getElementById('gym-phase-title');
                if (titleEl) titleEl.innerText = "GEPAUZEERD";
                triggerAudio('manual_override', "Gepauzeerd");
                if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.pause();
            }

            // ALWAYS open the modal to allow resuming or adjusting
            try {
                previewPauseOptions();
            } catch (e) {
                console.error("Preview options error:", e);
                // Fallback: show 0s
                document.getElementById('pause-duration-display').innerText = "--";
            }
            document.getElementById('pause-modal').style.display = 'flex';
        }

        function handleForcePauseMenu() {
            // Called by "Einde (Klik!)"
            // Goal: Pause app (if running) AND immediately show the menu.

            try {
                if (!isPaused) {
                    handlePauseClick(); // This pauses the app, sets isPaused=true
                }
            } catch (err) {
                console.error("ForcePause error:", err);
                // Fallback if handlePauseClick crashes
                isPaused = true;
                if (!pauseStartTime) pauseStartTime = Date.now();
            }

            // Explicitly show the modal now (handlePauseClick only does this if ALREADY paused)
            try {
                previewPauseOptions();
                document.getElementById('pause-modal').style.display = 'flex';
            } catch (e) {
                console.error("Modal open error:", e);
                // Last resort: simple show
                const m = document.getElementById('pause-modal');
                if (m) m.style.display = 'flex';
            }
        }

        // --- NEW PAUSE RESOLUTION LOGIC ---
        function previewPauseOptions() {
            const now = Date.now();
            currentPauseDuration = Math.ceil((now - pauseStartTime) / 1000); // Seconds paused
            document.getElementById('pause-duration-display').innerText = currentPauseDuration + "s";

            // 1. Push Endtime (Always possible)
            const newEndDate = new Date(targetEndTimeDate.getTime() + (currentPauseDuration * 1000));
            const oldEndStr = targetEndTimeDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
            const newEndStr = newEndDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
            const extraMin = Math.ceil(currentPauseDuration / 60);
            document.getElementById('btn-text-push').innerText = `Van ${oldEndStr} naar ${newEndStr} (+${extraMin}m)`;

            // 2. Catch up Work
            const workSteps = countRemainingSteps('work');
            const btnWork = document.getElementById('btn-catch-work');
            if (workSteps > 0) {
                const deduction = Math.ceil(currentPauseDuration / workSteps);
                const currentWork = getFirstStepTime('work');
                const newWork = currentWork - deduction;
                if (newWork >= 5) {
                    btnWork.disabled = false; btnWork.style.opacity = 1;
                    document.getElementById('btn-text-work').innerText = `Werk: ${currentWork}s -> ${newWork}s`;
                } else {
                    btnWork.disabled = true; btnWork.style.opacity = 0.5;
                    document.getElementById('btn-text-work').innerText = `Niet mogelijk (Werk wordt < 5s)`;
                }
            } else {
                btnWork.disabled = true; btnWork.style.opacity = 0.5; document.getElementById('btn-text-work').innerText = "Geen werksets meer";
            }

            // 3. Catch up Rest (Set)
            updateCatchUpButton('rest', 'btn-catch-rest', 'btn-text-rest', "Rust");
            // 4. Catch up Switch
            updateCatchUpButton('rest-exercise', 'btn-catch-switch', 'btn-text-switch', "Wissel");
            // 5. Catch up Round
            updateCatchUpButton('rest-long', 'btn-catch-round', 'btn-text-round', "Pauze");
        }

        // --- LIVE END TIME ADJUSTMENT LOGIC ---
        let liveBaseEndTime = null; // The projected end time BEFORE adjustment starts

        function openLiveEndAdjustment() {
            // 1. Pause App similar to handleForcePauseMenu
            try {
                if (!isPaused) {
                    handlePauseClick();
                }
            } catch (e) { console.error(e); isPaused = true; }

            // 2. Hide standard pause modal (if open)
            document.getElementById('pause-modal').style.display = 'none';

            // 3. Calc projected end time based on CURRENT schedule
            // We use the renderLiveSchedule() return value as the source of truth
            const projected = renderLiveSchedule(false) || targetEndTimeDate;
            liveBaseEndTime = new Date(projected);

            // 4. Set Input
            const timeStr = liveBaseEndTime.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
            document.getElementById('live-adjust-input').value = timeStr;

            // 5. Reset Diff UI
            calcLiveEndDiff();

            // 6. Show Modal
            document.getElementById('live-end-adjust-modal').style.display = 'flex';
        }

        function cancelLiveAdjustment() {
            document.getElementById('live-end-adjust-modal').style.display = 'none';
            // Return to standard pause menu
            document.getElementById('pause-modal').style.display = 'flex';
        }

        function calcLiveEndDiff() {
            const val = document.getElementById('live-adjust-input').value;
            if (!val) return;

            const [h, m] = val.split(':');
            const newDate = new Date();
            newDate.setHours(h, m, 0, 0);
            // Fix day wrapping
            const now = new Date();
            if (newDate < now && (now.getTime() - newDate.getTime() > 12 * 3600 * 1000)) {
                newDate.setDate(newDate.getDate() + 1);
            }

            const diffMs = newDate - liveBaseEndTime;
            const diffSec = Math.round(diffMs / 1000);

            const txt = document.getElementById('live-adjust-diff');
            if (diffSec > 0) {
                txt.innerText = `+${Math.floor(diffSec / 60)}m ${diffSec % 60}s`;
                txt.style.color = "#30D158";
            } else if (diffSec < 0) {
                txt.innerText = `-${Math.floor(Math.abs(diffSec) / 60)}m ${Math.abs(diffSec) % 60}s`;
                txt.style.color = "#FF453A";
            } else {
                txt.innerText = "Geen verschil";
                txt.style.color = "#888";
            }

            // Update buttons with projected effect
            updateLiveEffect('work', diffSec, 'btn-live-work', 'sub-live-work');
            updateLiveEffect('rest', diffSec, 'btn-live-rest', 'sub-live-rest');
            updateLiveEffect('switch', diffSec, 'btn-live-switch', 'sub-live-switch');
        }

        function updateLiveEffect(typeKey, totalDiffSec, btnId, subId) {
            const btn = document.getElementById(btnId);
            const sub = document.getElementById(subId);

            // Count remaining steps of this type
            // typeKey mapping: 'work'->'work', 'rest'->'rest', 'switch'->'rest-exercise' (roughly)
            let internalTypes = [];
            if (typeKey === 'work') internalTypes = ['work'];
            if (typeKey === 'rest') internalTypes = ['rest'];
            if (typeKey === 'switch') internalTypes = ['rest-exercise'];

            let count = 0;
            // Count ONLY future steps
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (internalTypes.includes(schedule[i].type)) count++;
            }

            if (count === 0) {
                btn.disabled = true;
                btn.style.opacity = 0.5;
                sub.innerText = "Niet beschikbaar (geen stappen)";
                return;
            }

            btn.disabled = false;
            btn.style.opacity = 1;
            const perStep = Math.round(totalDiffSec / count);
            const sign = perStep > 0 ? "+" : "";
            sub.innerText = `Effect: ${sign}${perStep}s per stap (${count}x)`;
        }

        function applyLiveEndAdjustment(typeKey) {
            const val = document.getElementById('live-adjust-input').value;
            if (!val) return;

            // Calc Diff
            const [h, m] = val.split(':');
            const newDate = new Date(); newDate.setHours(h, m, 0, 0);
            const now = new Date();
            if (newDate < now && (now.getTime() - newDate.getTime() > 12 * 3600 * 1000)) {
                newDate.setDate(newDate.getDate() + 1);
            }
            const diffMs = newDate - liveBaseEndTime;
            const diffSec = Math.round(diffMs / 1000);

            if (diffSec === 0) { cancelLiveAdjustment(); return; }

            // Map type
            let internalTypes = [];
            if (typeKey === 'work') internalTypes = ['work'];
            if (typeKey === 'rest') internalTypes = ['rest'];
            if (typeKey === 'switch') internalTypes = ['rest-exercise'];

            // Distribute
            let count = 0;
            let indices = [];
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (internalTypes.includes(schedule[i].type)) {
                    count++;
                    indices.push(i);
                }
            }

            if (count > 0) {
                const perStep = Math.floor(diffSec / count);
                let remainder = diffSec % count;

                indices.forEach(idx => {
                    let add = perStep;
                    if (remainder !== 0) {
                        // Distribute remainder 1 by 1
                        if (remainder > 0) { add++; remainder--; }
                        else { add--; remainder++; }
                    }

                    // Check minimum bounds? (e.g. don't go below 5s)
                    let newVal = schedule[idx].initialTime + add;
                    if (newVal < 5) newVal = 5; // Safety floor

                    schedule[idx].initialTime = newVal;
                    schedule[idx].time = newVal; // Update current state if it hasn't run yet? 
                    // Actually 'time' is active state. For future steps, time == initialTime usually.
                });

                triggerAudio('manual_override', "Schema aangepast");
            }

            // Close and Resume
            document.getElementById('live-end-adjust-modal').style.display = 'none';
            document.getElementById('live-end-adjust-modal').style.display = 'none';
            isPaused = false;
            if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.play();
            document.body.classList.remove('mode-pause');
            const btn = document.getElementById('btn-pause');
            if (btn) btn.innerText = "⏸";

            // Re-render
            renderLiveSchedule(true);
        }


        // --- SETUP WORK ADJUSTMENT LOGIC ---
        function openSetupWorkAdjustment() {
            // Ensure we have the latest calculation
            calculateRealTime();

            // Check if we have a valid work time
            if (workTimeSec <= 0) {
                alert("Er is nog geen geldig schema berekend. Vul eerst de instellingen in.");
                return;
            }

            document.getElementById('setup-work-input').value = workTimeSec;
            calcSetupWorkDiff();
            document.getElementById('setup-work-adjust-modal').style.display = 'flex';
        }

        function closeSetupWorkAdjustment() {
            document.getElementById('setup-work-adjust-modal').style.display = 'none';
        }

        function adjustSetupWorkInput(delta) {
            const inp = document.getElementById('setup-work-input');
            let val = parseInt(inp.value) || 0;
            val += delta;
            if (val < 5) val = 5;
            inp.value = val;
            calcSetupWorkDiff();
        }

        function calcSetupWorkDiff() {
            const val = parseInt(document.getElementById('setup-work-input').value) || 0;
            const diff = val - workTimeSec;
            const txt = document.getElementById('setup-work-diff');

            if (diff > 0) { txt.innerText = `+${diff}s per set`; txt.style.color = "#30D158"; }
            else if (diff < 0) { txt.innerText = `${diff}s per set`; txt.style.color = "#FF453A"; }
            else { txt.innerText = "Geen wijziging"; txt.style.color = "#888"; }

            // Update Buttons Text
            const btnDur = document.getElementById('btn-setup-duration');
            const subDur = document.getElementById('sub-setup-duration');
            const btnRest = document.getElementById('btn-setup-rest');
            const subRest = document.getElementById('sub-setup-rest');

            // 1. Duration Impact
            const rounds = parseInt(document.getElementById('rounds').value);
            const ex = parseInt(document.getElementById('exercises').value);
            const sets = parseInt(document.getElementById('sets').value);
            const totalWorkSets = rounds * ex * sets;

            // Current Duration Calculation
            const st = document.getElementById('startTimeValue').value;
            const et = document.getElementById('endTimeValue').value;
            const d1 = new Date("1970-01-01T" + st);
            const d2 = new Date("1970-01-01T" + et);
            if (d2 < d1) d2.setDate(d2.getDate() + 1);
            const curDurSec = (d2 - d1) / 1000;
            const curDurMin = Math.round(curDurSec / 60);

            const totalImpactSec = diff * totalWorkSets;
            const newDurSec = curDurSec + totalImpactSec;
            const newDurMin = Math.round(newDurSec / 60);
            const diffMin = newDurMin - curDurMin;

            if (totalImpactSec !== 0) {
                subDur.innerText = `Duur: ${curDurMin}m -> ${newDurMin}m (${diffMin > 0 ? '+' : ''}${diffMin}m)`;
                btnDur.disabled = false; btnDur.style.opacity = 1;
            } else {
                subDur.innerText = "Geen verandering";
                btnDur.disabled = true; btnDur.style.opacity = 0.5;
            }

            // 2. Rest Impact
            // Get current Rests
            const curRest = parseInt(document.getElementById('restSec').value);
            const curSwitch = parseInt(document.getElementById('exerciseRestSec').value);

            // Count slots
            const slotsRest = (sets - 1) * ex * rounds;
            const slotsSwitch = (ex - 1) * rounds;
            const totalSlots = slotsRest + slotsSwitch;

            if (totalSlots > 0 && totalImpactSec !== 0) {
                // We need to REMOVE totalImpactSec from the rest pool.
                // (Because if Work goes UP, Rest must go DOWN to keep duration same)
                const reducePerSlot = Math.round(totalImpactSec / totalSlots);

                const newRest = curRest - reducePerSlot;
                const newSwitch = curSwitch - reducePerSlot;

                if (newRest < 5 || newSwitch < 5) {
                    subRest.innerText = "Niet mogelijk (Rust wordt < 5s)";
                    btnRest.disabled = true; btnRest.style.opacity = 0.5;
                } else {
                    subRest.innerText = `Rust: ${curRest}s -> ${newRest}s`;
                    if (curSwitch !== curRest || newSwitch !== newRest) {
                        // If switch is different, show it too, or simplified
                        // Let's just show main "Rust" change as primary indicator
                        // subRest.innerText += ` | Wissel: ${curSwitch}s -> ${newSwitch}s`;
                    }
                    btnRest.disabled = false; btnRest.style.opacity = 1;
                }
            } else {
                subRest.innerText = "Geen relevant aantal rustmomenten";
                btnRest.disabled = true; btnRest.style.opacity = 0.5;
            }
        }

        function applySetupWorkAdjustment(mode) {
            const newVal = parseInt(document.getElementById('setup-work-input').value) || 0;
            const diff = newVal - workTimeSec;
            if (diff === 0) { closeSetupWorkAdjustment(); return; }

            if (mode === 'duration') {
                // Change Total Duration
                // We have totalImpactSec calculated above
                const rounds = parseInt(document.getElementById('rounds').value);
                const ex = parseInt(document.getElementById('exercises').value);
                const sets = parseInt(document.getElementById('sets').value);
                const totalWorkSets = rounds * ex * sets;
                const totalImpactSec = diff * totalWorkSets;

                // Update Duration Input (minutes)
                // Start with current selected duration
                // Actually, "Total Min" dropdown is the master controller usually.
                // But we might be in start/end mode.
                // Let's modify the End Time primarily? Or Total Duration?
                // Modifying Duration is safer for "Duration" mode.

                // Get current duration in seconds (based on current calculation budget)
                // We can grab it from startTime vs endTime
                const st = document.getElementById('startTimeValue').value;
                const et = document.getElementById('endTimeValue').value;
                // Helper to parse
                const d1 = new Date("1970-01-01T" + st);
                const d2 = new Date("1970-01-01T" + et);
                if (d2 < d1) d2.setDate(d2.getDate() + 1);
                let curDurSec = (d2 - d1) / 1000;

                let newDurSec = curDurSec + totalImpactSec;
                let newDurMin = Math.round(newDurSec / 60);

                // Update input and trigger sync
                // We need to update the Total Min dropdown IF it exists there, or add custom?
                // The app usually snaps to 5m increments.
                // But let's try updating End Time to match exact seconds?
                // Updating End Time is most flexible.

                const newEndDate = new Date(d1.getTime() + (newDurSec * 1000));
                const endStr = newEndDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
                document.getElementById('endTimeValue').value = endStr;

                // Also try to update TotalMin visual if close
                // Check if valid option exists?
                // document.getElementById('totalMin').value = newDurMin; // Might fail if not in options
                // Let's invoke syncTime('endtime') to cascade changes
                syncTime('endtime');
                saveToLocal();

            } else if (mode === 'rest') {
                // Change Rest Times to absorb diff
                const curRest = parseInt(document.getElementById('restSec').value);
                const curSwitch = parseInt(document.getElementById('exerciseRestSec').value);

                const rounds = parseInt(document.getElementById('rounds').value);
                const ex = parseInt(document.getElementById('exercises').value);
                const sets = parseInt(document.getElementById('sets').value);

                const slotsRest = (sets - 1) * ex * rounds;
                const slotsSwitch = (ex - 1) * rounds;
                const totalSlots = slotsRest + slotsSwitch;
                const totalWorkSets = rounds * ex * sets;
                const totalImpactSec = diff * totalWorkSets;

                if (totalSlots > 0) {
                    const reducePerSlot = Math.round(totalImpactSec / totalSlots);
                    let newRest = curRest - reducePerSlot;
                    let newSwitch = curSwitch - reducePerSlot;

                    if (newRest < 5) newRest = 5;
                    if (newSwitch < 5) newSwitch = 5;

                    // Update Selects (Create option if not exists)
                    setSelectValue('restSec', newRest);
                    setSelectValue('exerciseRestSec', newSwitch);

                    // Trigger Recalc
                    calculateRealTime();
                    saveToLocal();
                }
            }

            closeSetupWorkAdjustment();
        }

        // Helper to force set value in select (adding if missing)
        function setSelectValue(id, val) {
            const sel = document.getElementById(id);
            let found = false;
            for (let i = 0; i < sel.options.length; i++) {
                if (parseInt(sel.options[i].value) === val) {
                    sel.selectedIndex = i;
                    found = true;
                    break;
                }
            }
            if (!found) {
                const opt = document.createElement('option');
                opt.value = val;
                opt.innerText = val + "s";
                sel.add(opt);
                sel.value = val;
            }
        }

        // --- LIVE WORK ADJUSTMENT ---
        let liveBaseWorkTime = 0;


        function openLiveWorkAdjustment() {
            try { if (!isPaused) handlePauseClick(); } catch (e) { isPaused = true; }
            document.getElementById('pause-modal').style.display = 'none';

            // Find current Work Time (only regular exercises)
            let found = schedule.find((s, i) => i >= currentIndex && s.type === 'work' && s.info && s.info.exercise > 0);
            if (!found) found = { initialTime: 45 }; // Fallback

            liveBaseWorkTime = found.initialTime;
            document.getElementById('live-work-input').value = liveBaseWorkTime;

            calcLiveWorkDiff();
            document.getElementById('live-work-adjust-modal').style.display = 'flex';
        }

        function cancelLiveWorkAdjustment() {
            document.getElementById('live-work-adjust-modal').style.display = 'none';
            document.getElementById('pause-modal').style.display = 'flex';
        }

        function adjustLiveWorkInput(delta) {
            const inp = document.getElementById('live-work-input');
            let val = parseInt(inp.value) || 0;
            val += delta;
            if (val < 5) val = 5;
            inp.value = val;
            calcLiveWorkDiff();
        }

        function calcLiveWorkDiff() {
            const val = parseInt(document.getElementById('live-work-input').value) || 0;
            const diff = val - liveBaseWorkTime;

            const txt = document.getElementById('live-work-diff');
            if (diff > 0) { txt.innerText = `+${diff}s per set`; txt.style.color = "#30D158"; }
            else if (diff < 0) { txt.innerText = `${diff}s per set`; txt.style.color = "#FF453A"; }
            else { txt.innerText = "Geen wijziging"; txt.style.color = "#888"; }

            // Count occurrences (Regular Sets Only)
            let workCount = 0;
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (schedule[i].type === 'work' && schedule[i].info && schedule[i].info.exercise > 0) workCount++;
            }
            const totalImpact = diff * workCount;

            // 1. Push - Visual Feedback
            const subPush = document.getElementById('sub-work-push');
            subPush.innerText = `Totale impact: ${totalImpact > 0 ? '+' : ''}${totalImpact}s op eindtijd`;

            // 2. Compensate Rest
            const btnRest = document.getElementById('btn-work-rest');
            const subRest = document.getElementById('sub-work-rest');
            // calcLiveRestDiff uses: updateCompensateButton('work', diff, count, btnWork, subWork, "Werk");
            // Signature: (targetType, diffPerSource, sourceCount, btn, sub, label)
            // For Work->Rest: target=Rest. diffPerSource=diff. sourceCount=workCount.
            updateCompensateButton('rest', diff, workCount, btnRest, subRest, "Rust");

            // 3. Compensate Switch
            const btnSwitch = document.getElementById('btn-work-switch');
            const subSwitch = document.getElementById('sub-work-switch');
            updateCompensateButton('rest-exercise', diff, workCount, btnSwitch, subSwitch, "Wissel");
        }

        // Shared helper for predicting compensation (Used by Work & Rest adjustment)
        function updateCompensateButton(targetType, diffPerSource, sourceCount, btnEl, subEl, label) {
            let targetCount = 0;
            let currentTargetVal = 0;
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (schedule[i].type === targetType) {
                    targetCount++;
                    if (currentTargetVal === 0) currentTargetVal = schedule[i].initialTime;
                }
            }

            if (targetCount === 0) {
                btnEl.disabled = true; btnEl.style.opacity = 0.5;
                subEl.innerText = "Geen stappen meer";
                return;
            }

            const totalNeeded = diffPerSource * sourceCount;
            // If Work +10s (diff=+10). Count=10. TotalNeeded=+100s.
            // We need to REDUCE target by 100s.
            // deduction = 100 / targetCount.
            // new = current - deduction.

            const deductionPerStep = Math.floor(totalNeeded / targetCount);
            const newVal = currentTargetVal - deductionPerStep;

            if (newVal < 5) {
                btnEl.disabled = true; btnEl.style.opacity = 0.5;
                subEl.innerText = `Onmogelijk (${newVal}s < 5s)`;
            } else {
                btnEl.disabled = false; btnEl.style.opacity = 1;
                // If deduction is positive (Work increased), we subtract. Sign is MINUS.
                // If deduction is negative (Work decreased), we add. Sign is PLUS.
                const sign = deductionPerStep > 0 ? '-' : '+';
                subEl.innerText = `${label} wordt ${newVal}s (${sign}${Math.abs(deductionPerStep)}s)`;
            }
        }

        function applyLiveWorkAdjustment(mode) {
            const val = parseInt(document.getElementById('live-work-input').value) || 0;
            const diff = val - liveBaseWorkTime;
            if (diff === 0) { cancelLiveWorkAdjustment(); return; }

            // 1. Update all future WORK steps (Sets only)
            let workCount = 0;
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (schedule[i].type === 'work' && schedule[i].info && schedule[i].info.exercise > 0) {
                    schedule[i].initialTime = val;
                    schedule[i].time = val;
                    workCount++;
                }
            }

            // 2. Handle Compensation
            if (mode === 'rest' || mode === 'switch') {
                const targetType = (mode === 'switch') ? 'rest-exercise' : 'rest';
                const totalNeeded = diff * workCount;

                let targetIndices = [];
                for (let i = currentIndex + 1; i < schedule.length; i++) {
                    if (schedule[i].type === targetType) targetIndices.push(i);
                }

                if (targetIndices.length > 0) {
                    // We want to REDUCE Rest by totalNeeded.
                    const deductionTotal = totalNeeded;
                    const deductionPerStep = Math.floor(deductionTotal / targetIndices.length);
                    let remainder = deductionTotal % targetIndices.length;

                    targetIndices.forEach(idx => {
                        let deduct = deductionPerStep;
                        if (remainder !== 0) {
                            if (remainder > 0) { deduct++; remainder--; }
                            else { deduct--; remainder++; }
                        }

                        let time = schedule[idx].initialTime - deduct;
                        if (time < 5) time = 5;
                        schedule[idx].initialTime = time;
                        schedule[idx].time = time;
                    });
                }
            }

            triggerAudio('manual_override', "Werktijd aangepast");

            document.getElementById('live-work-adjust-modal').style.display = 'none';
            document.getElementById('pause-modal').style.display = 'none'; // Close all
            document.getElementById('pause-modal').style.display = 'none'; // Close all
            isPaused = false;
            if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.play();
            document.body.classList.remove('mode-pause');
            const btn = document.getElementById('btn-pause');
            if (btn) btn.innerText = "⏸";

            renderLiveSchedule(true);
        }

        // --- LIVE REST/SWITCH/ROUND ADJUSTMENT ---
        let liveBaseRestTime = 0;
        let liveRestType = 'rest'; // 'rest', 'rest-exercise', 'rest-long'

        function openLiveRestAdjustment(type) {
            liveRestType = type;
            // 1. Label
            const lbl = document.getElementById('live-rest-type-label');
            if (type === 'rest') lbl.innerText = "Rust (Set)";
            else if (type === 'rest-exercise') lbl.innerText = "Wissel";
            else if (type === 'rest-long') lbl.innerText = "Pauze (Ronde)";

            // 2. Pause
            try { if (!isPaused) handlePauseClick(); } catch (e) { isPaused = true; }
            document.getElementById('pause-modal').style.display = 'none';

            // 3. Find current value
            let found = schedule.find((s, i) => i >= currentIndex && s.type === type);
            if (!found) {
                // Fallback or alert if none exist
                found = { initialTime: (type === 'rest' ? 15 : (type === 'rest-exercise' ? 30 : 60)) };
            }

            liveBaseRestTime = found.initialTime;
            document.getElementById('live-rest-input').value = liveBaseRestTime;

            calcLiveRestDiff();
            document.getElementById('live-rest-adjust-modal').style.display = 'flex';
        }

        function cancelLiveRestAdjustment() {
            document.getElementById('live-rest-adjust-modal').style.display = 'none';
            document.getElementById('pause-modal').style.display = 'flex';
        }

        function adjustLiveRestInput(delta) {
            const inp = document.getElementById('live-rest-input');
            let val = parseInt(inp.value) || 0;
            val += delta;
            if (val < 5) val = 5;
            inp.value = val;
            calcLiveRestDiff();
        }

        function calcLiveRestDiff() {
            const val = parseInt(document.getElementById('live-rest-input').value) || 0;
            const diff = val - liveBaseRestTime;

            const txt = document.getElementById('live-rest-diff');
            if (diff > 0) { txt.innerText = `+${diff}s per keer`; txt.style.color = "#30D158"; }
            else if (diff < 0) { txt.innerText = `${diff}s per keer`; txt.style.color = "#FF453A"; }
            else { txt.innerText = "Geen wijziging"; txt.style.color = "#888"; }

            // Count occurrences
            let count = 0;
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (schedule[i].type === liveRestType) count++;
            }
            const totalImpact = diff * count;

            // 1. Push
            const subPush = document.getElementById('sub-rest-push');
            subPush.innerText = `Totale impact: ${totalImpact > 0 ? '+' : ''}${totalImpact}s op eindtijd`;

            // 2. Work (Trade)
            // If we add Rest (+), we must subtract Work (-).
            const btnWork = document.getElementById('btn-rest-work');
            const subWork = document.getElementById('sub-rest-work');

            updateCompensateButton('work', diff, count, btnWork, subWork, "Werk");
        }

        function applyLiveRestAdjustment(mode) {
            const val = parseInt(document.getElementById('live-rest-input').value) || 0;
            const diff = val - liveBaseRestTime;
            if (diff === 0) { cancelLiveRestAdjustment(); return; }

            // 1. Update all future steps of THIS type
            let count = 0;
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (schedule[i].type === liveRestType) {
                    schedule[i].initialTime = val;
                    schedule[i].time = val;
                    count++;
                }
            }

            // 2. Handle Compensation with WORK
            if (mode === 'work') {
                const totalNeeded = diff * count; // +20s total rest means we need -20s total work

                let workIndices = [];
                for (let i = currentIndex + 1; i < schedule.length; i++) {
                    if (schedule[i].type === 'work') workIndices.push(i);
                }

                if (workIndices.length > 0) {
                    const deductionPerStep = Math.floor(totalNeeded / workIndices.length);
                    let remainder = totalNeeded % workIndices.length;

                    workIndices.forEach(idx => {
                        let deduct = deductionPerStep;
                        if (remainder !== 0) {
                            if (remainder > 0) { deduct++; remainder--; }
                            else { deduct--; remainder++; }
                        }

                        let time = schedule[idx].initialTime - deduct;
                        if (time < 5) time = 5;
                        schedule[idx].initialTime = time;
                        schedule[idx].time = time;
                    });
                }
            }

            triggerAudio('manual_override', "Tijden aangepast");

            document.getElementById('live-rest-adjust-modal').style.display = 'none';
            document.getElementById('pause-modal').style.display = 'none';
            document.getElementById('pause-modal').style.display = 'none';
            isPaused = false;
            if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.play();
            document.body.classList.remove('mode-pause');
            const btn = document.getElementById('btn-pause');
            if (btn) btn.innerText = "⏸";

            renderLiveSchedule(true);
        }

        function updateCatchUpButton(type, btnId, textId, label) {
            const steps = countRemainingSteps(type);
            const btn = document.getElementById(btnId);
            if (steps > 0) {
                const deduction = Math.ceil(currentPauseDuration / steps);
                const currentVal = getFirstStepTime(type);
                const newVal = currentVal - deduction;
                if (newVal >= 5) {
                    btn.disabled = false; btn.style.opacity = 1;
                    document.getElementById(textId).innerText = `${label}: ${currentVal}s -> ${newVal}s`;
                } else {
                    btn.disabled = true; btn.style.opacity = 0.5;
                    document.getElementById(textId).innerText = `Niet mogelijk (${newVal}s < 5s)`;
                }
            } else {
                btn.disabled = true; btn.style.opacity = 0.5; document.getElementById(textId).innerText = "Niet van toepassing";
            }
        }

        function countRemainingSteps(type) {
            let count = 0;
            // Only count regular work steps, not fixed extra steps for adjustment
            for (let i = currentIndex; i < schedule.length; i++) {
                if (schedule[i].type === type) {
                    if (type === 'work') {
                        if (schedule[i].info && schedule[i].info.exercise > 0) count++;
                    } else {
                        count++;
                    }
                }
            }
            return count;
        }

        function getFirstStepTime(type) {
            for (let i = currentIndex; i < schedule.length; i++) {
                if (schedule[i].type === type) {
                    // FIX: Ignore Bonuses when checking for 'work' time (otherwise returns bonus duration)
                    if (type === 'work' && schedule[i].info && schedule[i].info.bonusId) continue;
                    return schedule[i].time;
                }
            }
            return 0;
        }

        let pendingEarlyStartSec = 0;

        function previewEarlyStartOptions() {
            console.log("DEBUG_PREVIEW (" + Date.now() + ")", { work: getFirstStepTime('work'), scheduleLen: schedule.length, workSteps: countRemainingSteps('work') });
            const startStr = document.getElementById('startTimeValue').value;
            const now = new Date();
            const [h, m] = startStr.split(':');
            const targetStart = new Date();
            targetStart.setHours(h, m, 0, 0);
            if (targetStart < now) targetStart.setDate(targetStart.getDate() + 1);

            // Calculate Surplus
            const diffMs = targetStart - now;
            if (diffMs <= 0) { performStart(); return; }

            pendingEarlyStartSec = Math.ceil(diffMs / 1000);

            // FIX: Hide Overlay and Stop Timer
            document.getElementById('pre-workout-overlay').style.display = 'none';
            if (preWorkoutInterval) clearInterval(preWorkoutInterval);

            // Show UI
            document.getElementById('pause-modal').style.display = 'flex';
            document.getElementById('pause-modal-title').innerText = "TE VROEG GESTART?";
            document.getElementById('pause-msg-p').innerHTML = `Je start <span style="color:#30D158; font-weight:bold;">${pendingEarlyStartSec}s</span> eerder.`;

            // 1. Shift End Time (Finish Early)
            // Logic: EndTime = EndTime - Surplus
            // Display: Old -> New
            const oldEndStr = document.getElementById('endTimeValue').value;
            // newEndDate isn't finalized until we performStart, but we can calc relative
            // Actually targetEndTimeDate is current input.
            const curEndVal = document.getElementById('endTimeValue').value;
            const nowCheck = new Date();
            const [eh, em] = curEndVal.split(':');
            const curEnd = new Date();
            curEnd.setHours(eh, em, 0, 0);
            if (curEnd < nowCheck) curEnd.setDate(curEnd.getDate() + 1);

            const newEndDate = new Date(curEnd.getTime() - diffMs);
            const newEndStr = newEndDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });

            document.getElementById('btn-text-push').innerText = `Eindtijd: ${oldEndStr} -> ${newEndStr} (Klaar: Eerder)`;

            // 2. Extra Work (Default behavior of performStart if we don't shift end)
            // We just need to show what happens.
            // Estimate new Work Time?
            // Current Work Time (Plan) vs New Work Time.
            // If we add surplus to duration, work increases.
            // Approx: NewWork = OldWork + (Surplus / WorkSteps)
            const workSteps = countRemainingSteps('work'); // This looks at current schedule (generated). OK.
            const btnWork = document.getElementById('btn-catch-work');
            if (workSteps > 0) {
                const currentWork = getFirstStepTime('work');
                const added = Math.floor(pendingEarlyStartSec / workSteps);
                const newWork = currentWork + added;
                btnWork.disabled = false; btnWork.style.opacity = 1;
                document.getElementById('btn-text-work').innerText = `Werk: ${currentWork}s -> ${newWork}s`;
            } else {
                btnWork.disabled = true; btnWork.style.opacity = 0.5; document.getElementById('btn-text-work').innerText = "-";
            }

            // 3/4/5. Extra Rest
            // btn-text-rest etc.
            const updateEarlyBtn = (type, btnId, txtId, label) => {
                const steps = countRemainingSteps(type);
                const btn = document.getElementById(btnId);
                if (steps > 0) {
                    const currentVal = getFirstStepTime(type);
                    const added = Math.floor(pendingEarlyStartSec / steps);
                    const newVal = currentVal + added;
                    btn.disabled = false; btn.style.opacity = 1;
                    document.getElementById(txtId).innerText = `${label}: ${currentVal}s -> ${newVal}s`;
                } else {
                    btn.disabled = true; btn.style.opacity = 0.5; document.getElementById(txtId).innerText = "-";
                }
            };

            updateEarlyBtn('rest', 'btn-catch-rest', 'btn-text-rest', "Rust");
            updateEarlyBtn('rest-exercise', 'btn-catch-switch', 'btn-text-switch', "Wissel");
            updateEarlyBtn('rest-long', 'btn-catch-round', 'btn-text-round', "Pauze");
        }

        function resolvePause(choice) {
            // Handle Jump Index First
            if (pendingJumpIndex !== null) {
                currentIndex = pendingJumpIndex;
                triggerAudio('manual_override', "Springen naar selectie");
                schedule[currentIndex].time = schedule[currentIndex].initialTime;
            }

            document.getElementById('pause-modal').style.display = 'none';
            // Restore Title default
            document.getElementById('pause-modal-title').innerText = "PAUZE VOORBIJ";
            document.getElementById('pause-msg-p').innerHTML = `Je hebt <span id="pause-duration-display" style="color:white; font-weight:bold;">0s</span> gepauzeerd.`;

            if (pendingEarlyStartSec > 0) {
                // EARLY START RESOLUTION
                const surplus = pendingEarlyStartSec;
                pendingEarlyStartSec = 0; // Reset

                // FIX: Only call performStart if NOT in Jump Mode
                // Capture jump state for later use
                const isJump = pendingJumpIndex !== null;

                if (choice === 'push') {
                    // Option 1: Shift End Time Earlier (Remove Surplus)

                    // FIX: Ensure targetEndTimeDate is defined (it might not be if performStart hasn't run yet)
                    if (!targetEndTimeDate) {
                        const endStr = document.getElementById('endTimeValue').value;
                        if (endStr) {
                            const [h, m] = endStr.split(':');
                            targetEndTimeDate = new Date();
                            targetEndTimeDate.setHours(h, m, 0, 0);
                            // Handle Day Wrap if needed (though unlikely for "Early" start unless around midnight)
                            if (targetEndTimeDate < new Date()) targetEndTimeDate.setDate(targetEndTimeDate.getDate() + 1);
                        } else {
                            // Fallback if inputs are empty? Should not happen in this flow.
                            targetEndTimeDate = new Date();
                        }
                    }

                    targetEndTimeDate = new Date(targetEndTimeDate.getTime() - (surplus * 1000));

                    // FIX: Sync Inputs to Reality so calculateRealTime works correctly
                    const now = new Date();
                    document.getElementById('startTimeValue').value = now.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
                    document.getElementById('endTimeValue').value = targetEndTimeDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });

                    // FORCE RECALC: Update global workTimeSec based on new inputs
                    // This ensures performStart -> generateScheduleData uses the updated (smaller) workTimeSec (e.g. 32s)
                    // instead of the old one (60s).
                    calculateRealTime();

                    // FIX: Conditionally adjust start time
                    if (isJump) {
                        workoutStartTime = new Date(workoutStartTime.getTime() - (surplus * 1000));
                    }

                    updateEndTimeDisplay();
                }

                if (!isJump) {
                    performStart();
                } else {
                    // Jump Mode: We are already running.
                    // Just need to handle the Surplus logic manually.
                    // Note: pendingJumpIndex was already applied at start of function.
                    pendingJumpIndex = null; // Clear it now
                    runStep(); // Kill Zombie Timer & Start New Step
                    renderLiveSchedule(); // Sync UI
                }

                if (choice === 'push') {
                    renderLiveSchedule(); // Update visible schedule immediately
                }
                else if (choice === 'work') {
                    // Option 2: Absorb into Work
                    // Do nothing! performStart already put it in Work.
                    triggerAudio('manual_override', "Extra werk tijd toegevoegd");
                }
                else {
                    // Option 3: Absorb into Rest/Switch/Round
                    // We need to move the surplus FROM Work TO Rest.
                    let typeToIncrease = '';
                    if (choice === 'rest') typeToIncrease = 'rest';
                    else if (choice === 'switch') typeToIncrease = 'rest-exercise';
                    else if (choice === 'round') typeToIncrease = 'rest-long';

                    const steps = countRemainingSteps(typeToIncrease);
                    const addition = Math.floor(surplus / steps);

                    for (let i = currentIndex; i < schedule.length; i++) {
                        if (schedule[i].type === typeToIncrease) {
                            schedule[i].time += addition;
                            schedule[i].initialTime += addition;
                        }
                    }
                    // Now Rest is higher. Duration matches inputs (Wide).
                    // We must recalculate work to shrink it (since we gave space to Rest).
                    recalculateForFixedEnd();
                    triggerAudio('manual_override', "Extra rust tijd toegevoegd");
                }

                // FIX: If we skipped performStart (Jump Mode), we must manually Resume!
                // Otherwise app stays paused.
                const btn = document.getElementById('btn-pause');
                if (btn.innerText === "▶️" || isPaused) {
                    btn.innerText = "⏸"; btn.classList.remove('paused');
                    btn.innerText = "⏸"; btn.classList.remove('paused');
                    isPaused = false;
                    if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.play();
                    document.body.classList.remove('mode-pause');
                    triggerAudio('manual_override', "We gaan weer door");
                }

                return;
            }

            // STANDARD PAUSE RESOLUTION
            const btn = document.getElementById('btn-pause');
            btn.innerText = "⏸"; btn.classList.remove('paused');
            btn.innerText = "⏸"; btn.classList.remove('paused');
            isPaused = false;
            if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.play();
            document.body.classList.remove('mode-pause');
            triggerAudio('manual_override', "We gaan weer door");

            // Apply Logic
            if (choice === 'push') {
                targetEndTimeDate = new Date(targetEndTimeDate.getTime() + (currentPauseDuration * 1000));
                updateEndTimeDisplay();
                stepEndTime += (currentPauseDuration * 1000);
                renderLiveSchedule(); // Update visible schedule immediately
            } else {
                stepEndTime += (currentPauseDuration * 1000);

                // Now Reduce
                let typeToReduce = '';
                if (choice === 'work') typeToReduce = 'work';
                else if (choice === 'rest') typeToReduce = 'rest';
                else if (choice === 'switch') typeToReduce = 'rest-exercise';
                else if (choice === 'round') typeToReduce = 'rest-long';

                const steps = countRemainingSteps(typeToReduce);
                const deduction = Math.ceil(currentPauseDuration / steps);

                // Apply deduction
                let currentStepReduced = false;
                for (let i = currentIndex; i < schedule.length; i++) {
                    if (schedule[i].type === typeToReduce) {
                        // Protect Extra Work from reduction if mode is 'work'
                        if (typeToReduce === 'work' && schedule[i].info.exercise === 0) continue;

                        schedule[i].time = Math.max(5, schedule[i].time - deduction);
                        schedule[i].initialTime = schedule[i].time;
                        if (i === currentIndex) currentStepReduced = true;
                    }
                }

                if (currentStepReduced) {
                    stepEndTime -= (deduction * 1000);
                    document.getElementById('countdown').innerText = Math.ceil((stepEndTime - Date.now()) / 1000);
                }
                renderLiveSchedule(); // Update visible schedule immediately
            }

            // Restore UI Classes
            const step = schedule[currentIndex];
            if (step) {
                if (step.type === 'work') document.body.classList.add('mode-work');
                else if (step.type === 'rest') document.body.classList.add('mode-rest');
                else if (step.type === 'rest-exercise') document.body.classList.add('mode-switch');
                else if (step.type === 'rest-long') document.body.classList.add('mode-long');

                document.getElementById('gym-phase-title').innerText = step.label;
                const titleEl = document.getElementById('gym-phase-title');
                titleEl.className = 'gym-phase-title';
                if (step.label === 'WERKEN' || step.label === 'RUST' || step.type === 'work') {
                    // Dynamic Sizing
                    if (step.label.length > 20) {
                        titleEl.classList.add('long-text');
                    } else if (step.label.length < 10) {
                        titleEl.classList.add('huge-text');
                    }
                }
            }
        }

        function updateEndTimeDisplay() {
            const timeStr = targetEndTimeDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
            document.getElementById('val-endtime').innerText = timeStr;
        }


        function updateProgressRings(currentSec, totalSec) {
            // Inner Ring (Step) uses REVERSE logic (starts full, goes to empty)
            const ringStep = document.getElementById('ring-step');
            if (ringStep && totalSec > 0) {
                const totalC = 251.3; // 2 * pi * 40
                // pct is % LEFT
                let pct = currentSec / totalSec;
                if (pct > 1) pct = 1; if (pct < 0) pct = 0;

                const offset = totalC * (1 - pct);
                ringStep.style.strokeDashoffset = offset;
            } else {
                // console.log("Ring update failed", totalSec);
            }

            // Outer Ring (Total)
            const ringTotal = document.getElementById('ring-total');
            if (ringTotal) {
                // FIXED: Force 0% during Prep Phase (User Requirement)
                if (schedule[currentIndex] && schedule[currentIndex].type === 'prep') {
                    const totalC = 301.6; // 2 * pi * 48
                    ringTotal.style.strokeDashoffset = totalC; // Empty
                    const ringPctEl = document.getElementById('ring-percent');
                    if (ringPctEl) ringPctEl.innerText = "0%";
                    return;
                }

                // NEW LOGIC: Set-Based Progress (User Request)
                // Formula: (Total Work Sets - Remaining Work Sets) / Total Work Sets
                // Filter: type === 'work' AND info.exercise > 0 (excludes bonuses/toetjes)

                try {
                    // 1. Base Progress: Completed Sets / Total Sets
                    let totalWorkSets = 0;
                    let remainingWorkSets = 0;

                    schedule.forEach((s, i) => {
                        if (s.type === 'work' && s.info && s.info.exercise > 0) {
                            totalWorkSets++;
                            if (i >= currentIndex) remainingWorkSets++;
                        }
                    });

                    if (totalWorkSets > 0) {
                        let basePct = (totalWorkSets - remainingWorkSets) / totalWorkSets;
                        if (basePct < 0) basePct = 0;
                        if (basePct > 1) basePct = 1;

                        // 2. Time Factor: Interpolate remaining % over remaining time
                        let finalPct = basePct;
                        const anchorStart = window.lastStepChangeTime || Date.now();

                        if (targetEndTimeDate && anchorStart) {
                            const nowMs = Date.now();
                            const totalDurationMs = targetEndTimeDate.getTime() - anchorStart;
                            const elapsedMs = nowMs - anchorStart;

                            if (totalDurationMs > 1000) {
                                let timeFactor = elapsedMs / totalDurationMs;
                                if (timeFactor > 1) timeFactor = 1;
                                if (timeFactor < 0) timeFactor = 0;

                                // Fill the gap (1 - basePct)
                                const gap = 1.0 - basePct;
                                finalPct = basePct + (gap * timeFactor);
                            }
                        }

                        if (finalPct > 1) finalPct = 1;
                        if (finalPct < 0) finalPct = 0;
                        if (isNaN(finalPct)) finalPct = 0;

                        const totalC = 301.6;
                        const offset = totalC * (1 - finalPct);
                        if (!isNaN(offset)) {
                            ringTotal.style.strokeDashoffset = offset;
                        }

                        // Update Percentage Text
                        const ringPctEl = document.getElementById('ring-percent');
                        if (ringPctEl) {
                            ringPctEl.innerText = Math.round(finalPct * 100) + "%";
                        }

                        // TIMELINE MILESTONES (Based on %)
                        if (finalPct >= 0.25 && !milestonesTriggered.m25) {
                            triggerAudio('mile_start', "Goede start");
                            milestonesTriggered.m25 = true;
                        }
                        if (finalPct >= 0.50 && !milestonesTriggered.m50) {
                            triggerAudio('mile_half', "Helft");
                            milestonesTriggered.m50 = true;
                        }
                        if (finalPct >= 0.75 && !milestonesTriggered.m75) {
                            triggerAudio('mile_end', "Eindsprint");
                            milestonesTriggered.m75 = true;
                        }
                    }
                } catch (err) {
                    console.error("Safe Progress Error:", err);
                }
            }
        }

        function finish() {
            document.body.className = 'mode-finish';
            document.getElementById('gym-phase-title').innerText = "KLAAR!";
            document.getElementById('gym-phase-title').classList.remove('huge-text');
            document.getElementById('countdown').innerText = "🎉";
            document.getElementById('gym-stats-container').style.display = 'none';
            document.getElementById('btn-pause').style.display = 'none';
            // Force 100% progress
            updateProgressRings(0, 1);
            const ringTotal = document.getElementById('ring-total');
            if (ringTotal) ringTotal.style.strokeDashoffset = 0; // Ensure full

            clearInterval(timerInterval);
            triggerAudio('finish', "Training klaar");
        }

        function fullReset() {
            if (!confirm("Weet je zeker dat je alle instellingen wilt resetten naar standaard?")) return;

            document.getElementById('rounds').value = appDefaults.rounds;
            document.getElementById('exercises').value = appDefaults.exercises;
            document.getElementById('sets').value = appDefaults.sets;
            document.getElementById('restSec').value = appDefaults.restSec;
            document.getElementById('exerciseRestSec').value = appDefaults.exerciseRestSec;
            document.getElementById('roundRestSec').value = appDefaults.roundRestSec;
            document.getElementById('totalMin').value = appDefaults.totalMin;
            if (document.getElementById('coach-preset-live')) document.getElementById('coach-preset-live').value = appDefaults.coachPreset; // UPDATED

            for (let i = 0; i < 3; i++) {
                document.getElementById(`bonus${i + 1}-name`).value = appDefaults.bonuses[i].name;
                document.getElementById(`bonus${i + 1}-duration`).value = appDefaults.bonuses[i].duration;
                document.getElementById(`bonus${i + 1}-freq`).value = appDefaults.bonuses[i].freq;
            }

            // Calculations
            syncTime('duration');
            calculateRealTime();

            // Manual Coach Reset (Silent - No Validation Modal)
            const defCoach = appDefaults.coachPreset;
            if (coachPresets[defCoach]) {
                speechSettings = JSON.parse(JSON.stringify(coachPresets[defCoach]));
                renderAudioToggles();
            }

            updateBonusVisibility(); // Fix UI
            saveToLocal();
        }

        function resetApp() {
            clearInterval(timerInterval);
            // Force Tabataman on reset (User Request)
            try {
                let s = JSON.parse(localStorage.getItem('fnh_settings_v8') || "{}");
                s.coachPreset = 'tabataman';
                localStorage.setItem('fnh_settings_v8', JSON.stringify(s));
            } catch (e) { console.error("Reset pref fail", e); }
            location.reload();
        }

        function confirmStop() { if (confirm("Weet je zeker dat je de training wilt stoppen?")) { bgMusicManager.stopWorkout(); resetApp(); } }

        // Define cancelPause if not exists (fallback)
        function cancelPause() {
            document.getElementById('pause-modal').style.display = 'none';
            if (isPaused) {
                isPaused = false;
                document.body.classList.remove('mode-pause');
                const btn = document.getElementById('btn-pause');
                if (btn) { btn.innerText = "⏸"; btn.classList.remove('paused'); }
                triggerAudio('manual_override', "We gaan weer door");
                if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.play();
            }
        }

        // --- NEW FEATURES: LIVE SCHEDULE & NAVIGATION ---

        function renderLiveSchedule(forceRebuild = false) {
            const tbody = document.getElementById('live-table-body');

            // 1. Check if we need to build the rows (First run or Force)
            // We filter out 'finish' step, so count appropriately.
            const schedItems = schedule.filter(s => s.type !== 'finish');
            const needsBuild = forceRebuild || tbody.children.length === 0 || tbody.children.length !== schedItems.length;

            if (needsBuild) {
                tbody.innerHTML = "";
            }

            // 2. Setup Time Calculation
            let tempDate = new Date(workoutStartTime || Date.now());

            schedule.forEach((item, index) => {
                if (item.type === 'finish') return;

                let tr = document.getElementById(`sched-row-${index}`);

                // Build Row if needed
                if (needsBuild) {
                    tr = document.createElement('tr');
                    tr.id = `sched-row-${index}`;
                    tr.onclick = () => jumpToStep(index);

                    const tdTime = document.createElement('td'); // Cell 0
                    const tdName = document.createElement('td'); // Cell 1
                    const tdDur = document.createElement('td');  // Cell 2
                    tdDur.style.textAlign = "right";

                    tr.appendChild(tdTime);
                    tr.appendChild(tdName);
                    tr.appendChild(tdDur);
                    tbody.appendChild(tr);
                }

                // 4. Advance Time (Real Time Clock Logic) & Render
                let dur = item.initialTime;

                // Calculate Start & End Date for this step
                // startTime is simply tempDate (current pointer)
                const startTime = new Date(tempDate);
                let endTime = new Date(tempDate);

                if (index === currentIndex) {
                    // Special case: Current step logic matching the main loop
                    if (stepEndTime) {
                        // If running, we know the exact absolute end time
                        endTime = new Date(stepEndTime);
                    } else {
                        // Not running yet?
                        endTime.setSeconds(endTime.getSeconds() + dur);
                    }
                } else {
                    // Future step
                    endTime.setSeconds(endTime.getSeconds() + dur);
                }

                if (tr) {
                    // Update Class
                    if (index < currentIndex) tr.className = "past-row";
                    else if (index === currentIndex) tr.className = "active-row";
                    else tr.className = "future-row";

                    // Update Time (Start <br> End)
                    const fmt = (d) => d.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) + "." + d.getMilliseconds().toString().padStart(3, '0');
                    tr.children[0].innerHTML = `<span style="color:#fff">${fmt(startTime)}</span><br><span style="color:#555">${fmt(endTime)}</span>`;

                    // Update Name (Static, but safe to refresh)
                    let desc = item.label;
                    if (item.info && item.info.round && item.info.exercise > 0) desc += ` <span style='color:#888; font-size:11px;'>(R${item.info.round}/E${item.info.exercise}/S${item.info.set})</span>`;
                    tr.children[1].innerHTML = desc;

                    // Update Duration
                    tr.children[2].innerText = dur + "s";
                }

                // Advance the pointer for the NEXT loop iteration
                // The start of the next step is the end of this step.
                tempDate = new Date(endTime);
            });

            // --- UPDATE STATS ---
            updateEndTimeDisplay();

            // Update Work Time Display
            // Find first active or future 'work' step to show current setting (Excluding Bonuses)
            let workStep = schedule.find((s, i) => i >= currentIndex && s.type === 'work' && (!s.info || !s.info.bonusId));
            const workDisplay = document.getElementById('val-worktime');
            if (workDisplay) workDisplay.innerText = workStep ? (workStep.initialTime + "s") : "-";

            // Update Rest/Switch/Round Displays
            const updateStat = (type, id) => {
                const el = document.getElementById(id);
                if (!el) return;
                const found = schedule.find((s, i) => i >= currentIndex && s.type === type);
                el.innerText = found ? (found.initialTime + "s") : "-";
            };
            updateStat('rest', 'val-rest');
            updateStat('rest-exercise', 'val-switch');
            updateStat('rest-long', 'val-pause-round');

            return tempDate; // Return the final calculated end time
        }

        function updateLiveScheduleHighlight() {
            // Remove old highlight
            // FIX: Selector was '.live-table tr' which INCLUDED the <thead> row!
            // This caused index 0 to target the Header, and Index 1 to target the first body row.
            // Result: Highlight was always 1 step behind (OFFSET BY 1).
            const rows = document.querySelectorAll('#live-table-body tr');

            rows.forEach((r, idx) => {
                if (idx < currentIndex) r.className = "past-row";
                else if (idx === currentIndex) {
                    r.className = "active-row";
                    // Scroll disabled to keep focus on top of page
                }
                else r.className = "future-row";
            });
        }

        function handleNextClick() {
            if (currentIndex < schedule.length - 1) {
                currentIndex++;
                schedule.forEach(s => delete s.hasPlayedEntry); // Allow audio to play for new step
                stepEndTime = Date.now() + (schedule[currentIndex].time * 1000);
                triggerAudio('manual_override', "Volgende");
                renderLiveSchedule(); // Update times potentially?
                runStep();
            } else {
                finish();
            }
        }

        function handlePrevClick() {
            if (currentIndex > 0) {
                currentIndex--;
                schedule.forEach(s => delete s.hasPlayedEntry); // Allow audio to play for previous step
                // Restore time for the step we are going BACK to (full duration)
                schedule[currentIndex].time = schedule[currentIndex].initialTime;
                stepEndTime = Date.now() + (schedule[currentIndex].time * 1000);
                triggerAudio('manual_override', "Vorige");
                renderLiveSchedule();
                runStep();
            }
        }

        // SMART JUMP LOGIC
        let pendingJumpIndex = null;

        function jumpToStep(index) {
            if (index < 0 || index >= schedule.length) return;
            if (index === currentIndex) return;

            // 1. Pause App (to freeze state)
            if (!isPaused) handlePauseClick();

            // 2. Calculate Diff
            const diff = calculateJumpDiff(index);
            pendingJumpIndex = index;

            // 3. Show Modal
            document.getElementById('pause-modal').style.display = 'flex';

            if (diff > 0) {
                // SURPLUS (Skipping Forward) -> "Early Start" Logic
                // We have gained time.
                pendingEarlyStartSec = diff;
                pendingPauseDur = 0;
                document.getElementById('pause-modal-title').innerText = "SPRINGEN (OVERSLAAN)";
                document.getElementById('pause-msg-p').innerHTML = `Je slaat <span style="color:#30D158; font-weight:bold;">${diff}s</span> over.`;
            } else {
                // DEFICIT (Going Back) -> "Pause" Logic
                // We need more time.
                pendingEarlyStartSec = 0;
                pendingPauseDur = Math.abs(diff);
                document.getElementById('pause-modal-title').innerText = "SPRINGEN (TERUG)";
                document.getElementById('pause-msg-p').innerHTML = `Je voegt <span style="color:#FF9F0A; font-weight:bold;">${Math.abs(diff)}s</span> toe.`;
            }

            // Update End Time Preview Button
            const oldEndStr = document.getElementById('endTimeValue').value;
            // Approximate new end time based on diff
            // If diff > 0 (Surplus), new end is earlier (old - diff)
            // If diff < 0 (Deficit), new end is later (old + abs(diff))
            // Note: targetEndTimeDate is the reference.

            const curEnd = targetEndTimeDate;
            const newEndDate = new Date(curEnd.getTime() - (diff * 1000)); // diff is positive for surplus (earlier), negative for deficit (later)
            const newEndStr = newEndDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });

            document.getElementById('btn-text-push').innerText = `Eindtijd: ${oldEndStr} -> ${newEndStr}`;
        }

        function calculateJumpDiff(targetIdx) {
            // Returns SECONDS difference.
            // Positive = Surplus (Skipping / Early)
            // Negative = Deficit (Adding / Late)

            // 1. Current Remaining (Real)
            // Time remaining in current step + full time of all future steps
            let currentRem = 0;
            if (stepEndTime > Date.now()) currentRem += (stepEndTime - Date.now()) / 1000;
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                currentRem += schedule[i].initialTime;
            }

            // 2. Target Remaining (Hypothetical)
            // Full time of target step + full time of all steps AFTER target
            let targetRem = schedule[targetIdx].initialTime;
            for (let i = targetIdx + 1; i < schedule.length; i++) {
                targetRem += schedule[i].initialTime;
            }

            // Diff = Current - Target
            // Example: Current has 100s rem. Target has 20s rem.
            // Diff = 80s (We have 80s extra "surplus" if we jump).
            return Math.ceil(currentRem - targetRem);
        }

        function cancelPause() {
            document.getElementById('pause-modal').style.display = 'none';
            pendingJumpIndex = null;
            pendingEarlyStartSec = 0;
            pendingPauseDur = 0;
            // Just resume
            handlePauseClick();
        }

        // --- iOS Audio Guide Popup ---
        (function checkDeviceAndInstruct() {
            // 1. Check of gebruiker dit permanent verborgen heeft
            if (localStorage.getItem("fnh_hide_audio_guide") === "true") return;

            // 2. Detecteer iOS
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.userAgent.includes("Mac") && "ontouchend" in document);
            if (!isIOS) return;

            // 3. Bepaal Model Type
            const width = Math.min(window.screen.width, window.screen.height);
            let deviceType = "switch";

            if (navigator.userAgent.includes("iPad") || (navigator.userAgent.includes("Mac") && "ontouchend" in document)) {
                deviceType = "ipad";
            }
            else if (width === 402 || width === 440) {
                deviceType = "action"; // iPhone 16 Pro / Max
            }
            else if (width === 393 || width === 430) {
                deviceType = "ambiguous"; // iPhone 14/15/16 mix
            }

            // 4. Toon Popup
            // Wait slightly to ensure DOM is ready if script is at end of body
            setTimeout(() => showAudioPopup(deviceType), 500);
        })();

        function showAudioPopup(type) {
            if (sessionStorage.getItem("audio_popup_seen")) return;

            let title = "🔈 Geluid Aanzetten";
            let msg = "";
            let icon = "";

            switch (type) {
                case "ipad":
                    title = "Instellen";
                    icon = "📱";
                    msg = `
                        <b>1. Bedieningspaneel:</b> Veeg rechtsboven omlaag.<br>
                        <b>2. Belletje:</b> Zorg dat het bel-icoon 🔔 AAN staat.<br>
                        <b>3. Focus:</b> Zet 'Niet Storen' aan.
                    `;
                    break;
                case "action":
                    title = "Instellen";
                    icon = "🔘";
                    msg = `
                        <b>Optie 1:</b> Houd de <b>Actieknop</b> (zijkant) ingedrukt tot 'Stille modus: Uit'.<br>
                        <b>Optie 2:</b> Via Bedieningspaneel (belletje 🔔).
                    `;
                    break;
                case "ambiguous":
                    title = "Instellen";
                    icon = "📱";
                    msg = `
                        <b>Heb je een Actieknop?</b><br> Houd ingedrukt tot Stille Modus UIT gaat.<br><br>
                        <b>Heb je een Schakelaar?</b><br> Zet het schuifje links omhoog.
                    `;
                    break;
                default:
                    title = "Zet Geluid Aan";
                    icon = "🔕 ➡️ 🔔";
                    msg = `
                        <b>De fysieke schakelaar:</b><br>
                        Zet het schuifje aan de linkerkant omhoog.<br>
                        <i>(Geen oranje vlakje zichtbaar!)</i>
                    `;
                    break;
            }

            const div = document.createElement("div");
            div.style.cssText = "position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:99999; display:flex; align-items:center; justify-content:center; padding:20px; backdrop-filter:blur(5px);";

            div.innerHTML = `
                <div style="background:#1c1c1e; color:white; padding:20px; border-radius:20px; max-width:340px; text-align:center; border:1px solid #333; box-shadow:0 10px 30px rgba(0,0,0,0.5);">
                    <div style="font-size:35px; margin-bottom:10px;">${icon}</div>
                    <h2 style="margin:0 0 10px 0; color:#30D158; font-size:20px;">${title}</h2>
                    <div style="font-size:13px; color:#ccc; line-height:1.4; text-align:left; margin-bottom:15px;">${msg}</div>
                    
                    <div style="background:rgba(255, 214, 10, 0.1); border:1px solid rgba(255, 214, 10, 0.3); padding:10px; border-radius:8px; text-align:left; margin-bottom:15px;">
                        <div style="font-size:12px; font-weight:bold; color:#FFD60A; margin-bottom:2px;">🔒 PRO TIP: Begeleide Toegang</div>
                        <div style="font-size:11px; color:#ddd;">
                            Voorkomt dat je de app wegveegt én blokkeert notificaties.
                            <br><br>
                            👉 <b>Druk 3x snel op de zijknop</b> om te starten.
                        </div>
                    </div>

                    <label style="display:flex; align-items:center; justify-content:center; margin-bottom:15px; cursor:pointer; font-size:12px; color:#888;">
                        <input type="checkbox" id="hide-future-popup" style="margin-right:8px; transform:scale(1.2); accent-color:#30D158;">
                        Dit bericht niet meer tonen
                    </label>

                    <button id="btn-audio-ok" style="background:#0A84FF; color:white; border:none; padding:12px 30px; border-radius:12px; font-weight:bold; font-size:16px; cursor:pointer; width:100%;">
                        Begrepen ✅
                    </button>
                </div>
            `;

            document.body.appendChild(div);

            document.getElementById("btn-audio-ok").onclick = () => {
                if (document.getElementById("hide-future-popup").checked) {
                    localStorage.setItem("fnh_hide_audio_guide", "true");
                } else {
                    sessionStorage.setItem("audio_popup_seen", "true");
                }
                div.remove();
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (ctx.state !== 'running') ctx.resume()
            };
        }

        // IMPROVED: Cross-browser & iOS Friendly Fullscreen
        function toggleFullScreen() {
            const doc = window.document;
            const docEl = doc.documentElement;

            // 1. Check for iOS
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.userAgent.includes("Mac") && "ontouchend" in doc);

            if (isIOS) {
                // iOS doesn't support the fullscreen API for web apps in Safari reliably.
                // Best practice is "Add to Home Screen" (Standalone mode).
                const isStandalone = ('standalone' in window.navigator) && (window.navigator.standalone);

                if (!isStandalone) {
                    showIOSFullscreenHelp();
                    return;
                }
            }

            // 2. Standard API
            const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
            const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

            if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
                if (requestFullScreen) {
                    requestFullScreen.call(docEl).catch(err => {
                        console.warn("Fullscreen request denied/failed", err);
                        // Fallback: If blocked (often on iOS), show help
                        if (isIOS) showIOSFullscreenHelp();
                    });
                }
            } else {
                if (cancelFullScreen) {
                    cancelFullScreen.call(doc);
                }
            }
        }

        function showIOSFullscreenHelp() {
            // Check if already seen session-wise to avoid annoyance, unless user clicks button explicitly? 
            // Actually, if they click the button, they WANT fullscreen, so show it every time.

            const div = document.createElement("div");
            div.style.cssText = "position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:200005; display:flex; align-items:center; justify-content:center; padding:20px; backdrop-filter:blur(5px);";

            div.innerHTML = `
                <div style="background:#1c1c1e; color:white; padding:25px; border-radius:24px; max-width:340px; text-align:center; border:1px solid #333; box-shadow:0 10px 40px rgba(0,0,0,0.6);">
                    <div style="font-size:40px; margin-bottom:15px;">📱</div>
                    <h2 style="margin:0 0 10px 0; color:#30D158; font-size:22px;">Volledig Scherm</h2>
                    <div style="font-size:14px; color:#ccc; line-height:1.5; text-align:left; margin-bottom:20px;">
                        Op iPhone/iPad werkt dit knopje niet direct in Safari.
                        <br><br>
                        <b>Voor de beste ervaring:</b>
                        <ol style="margin:10px 0; padding-left:20px; color:#fff;">
                            <li>Tik op de <b style="color:#0A84FF">Deel-knop</b> 🛫 (onderin).</li>
                            <li>Kies <b style="color:#fff">"Zet op beginscherm"</b> ➕.</li>
                        </ol>
                        Start de app daarna via het nieuwe icoontje!
                    </div>
                    <button id="btn-ios-close" style="background:#333; color:white; border:none; padding:12px 30px; border-radius:12px; font-weight:bold; font-size:16px; cursor:pointer; width:100%;">
                        Sluiten
                    </button>
                </div>
            `;
            document.body.appendChild(div);
            document.getElementById("btn-ios-close").onclick = () => div.remove();
        }

        // --- ROBUST iOS PWA AUDIO FIX ---
        // Solves "intermittent audio" by forcing context resume on touch & visibility change
        function unlockIOSAudio() {
            // 1. Web Audio API Context
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
                // Access the global context if we can find it, or just create a dummy to wake the subsystem?
                // Better: If we have a global context variable (created in playMp3WebAudio), use it.
                // If not, we can't easily reach it unless we exposed it.
                // However, usually one context per page is best practice.
                // Let's assume standard behavior:
                // We'll trust that 'playMp3WebAudio' (if it exists) manages its context.
                // We can try to resume IT if we can find the variable.
                // Looking at standard implementations, often 'audioCtx' is global.
                if (window.audioCtx && window.audioCtx.state === 'suspended') {
                    window.audioCtx.resume().then(() => console.log("AudioContext Resumed by Touch"));
                }
            }

            // 2. HTML5 Audio Elements (Warmup)
            // Silence is golden.
        }

        // Global unlocker for ANY AudioContext created in the future
        document.addEventListener('touchstart', function () {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext && window.audioCtx) {
                window.audioCtx.resume();
            }
        }, { passive: true });

        document.addEventListener('click', function () {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext && window.audioCtx) {
                window.audioCtx.resume();
            }
        }, { passive: true });

        // VISIBILITY KEEP-ALIVE
        document.addEventListener('visibilitychange', function () {
            if (!document.hidden) {
                // App came to foreground -> Force Resume
                console.log("App Foregrounded -> Resuming Audio");
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext && window.audioCtx && window.audioCtx.state === 'suspended') {
                    window.audioCtx.resume();
                }
                // Also refresh Background Music if needed
                if (bgMusicManager && bgMusicManager.audio && !bgMusicManager.audio.paused) {
                    // Check if it actually stopped playing?
                    // Sometimes iOS pauses it.
                    // If we expect it to be playing, we might need to nudge it.
                }
            }
        });

    </script>
    <div id="pre-workout-overlay" class="modal-overlay epic-overlay"
        style="display:none; flex-direction:column; justify-content:center; align-items:center; background:black; color:white;">
        <div style="font-size:18px; color:#888; text-transform:uppercase; letter-spacing:4px; margin-bottom:10px;">
            TRAINING BEGINT OVER</div>

        <div id="pre-workout-timer" class="epic-timer" style="font-size:120px; font-weight:900; line-height:1;">
            00:00
        </div>

        <!-- NEW START TIME INFO -->
        <div id="pre-workout-start-time"
            style="font-size:24px; color:#30D158; font-weight:bold; margin-bottom:20px; text-transform:uppercase; letter-spacing:1px; text-shadow: 0 0 10px rgba(48,209,88,0.4);">
            STARTTIJD: --:--
        </div>



        <button onclick="previewEarlyStartOptions()" class="action-btn"
            style="margin-top:50px; padding:15px 40px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); backdrop-filter:blur(10px); width:auto;">
            🚀 NU BEGINNEN (OVERSLAAN)
        </button>
        <script>
            function getFingerprint() {
                let fp = localStorage.getItem('fnh_fingerprint');
                if (!fp) {
                    fp = 'user_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                    localStorage.setItem('fnh_fingerprint', fp);
                }
                return fp;
            }

            function logWorkoutToSheet() {
                const url =
                    "https://script.google.com/macros/s/AKfycbzjwH5TfLJEinllUn3wYlQE17uno0DdnLoBaG1FmdMeVBUE0wd5-pf07TEoOg6jj2sF/exec";

                // Safe Retrieval
                const totalMinEl = document.getElementById('totalMin');
                const totalMinText = totalMinEl && totalMinEl.options.length > 0 ?
                    totalMinEl.options[totalMinEl.selectedIndex].text : "Err";

                const payload = {
                    fingerprint: getFingerprint(),
                    rounds: document.getElementById('rounds').value,
                    exercises: document.getElementById('exercises').value,
                    sets: document.getElementById('sets').value,
                    totalMin: totalMinText,
                    coach: document.getElementById('coach-preset-live') ? document.getElementById('coach-preset-live').value : 'unknown', // UPDATED
                    startTime: new Date().toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' })
                };

                console.log("Logging Payload:", payload);

                // Fire and forget (no-cors prevents reading response but allows sending)
                // Use text/plain to avoid CORS preflight (OPTIONS) which Apps Script doesn't handle
                fetch(url, {
                    method: 'POST',
                    mode: 'no-cors',
                }).then(() => console.log("Log sent (blind)")).catch(e => console.log("Logging error", e));
            }
            // --- PULL TO REFRESH (Custom) ---
            (function initPullToRefresh() {
                // 1. Inject CSS
                const style = document.createElement('style');
                style.innerHTML = `
                #ptr-spinner {
                    position: fixed; top: -60px; left: 0; right: 0; height: 60px;
                    display: flex; align-items: center; justify-content: center;
                    z-index: 99999; pointer-events: none; /* Passes touches through until visible/active? No, we need to see it. */
                    transition: top 0.2s;
                }
                #ptr-icon {
                    font-size: 24px; color: #30D158;
                    transition: transform 0.2s;
                    text-shadow: 0 0 10px black;
                }
                .ptr-refreshing #ptr-spinner { top: 20px; }
                .ptr-refreshing #ptr-icon { animation: ptr-spin 1s linear infinite; }
                @keyframes ptr-spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
            `;
                document.head.appendChild(style);

                // 2. Inject DOM
                const ptr = document.createElement('div');
                ptr.id = 'ptr-spinner';
                ptr.innerHTML = '<div id="ptr-icon">⬇️</div>';
                document.body.appendChild(ptr);

                // 3. Variables
                let startY = 0;
                let isDragging = false;
                const threshold = 250; // Increased to make it harder (user request)

                // 4. Touch Handlers
                document.addEventListener('touchstart', (e) => {
                    // Only enable if at top AND critical overlays are NOT active
                    // We allow it on Setup Screen (Start Page) now.
                    const isBlockingOverlay = document.getElementById('pause-modal').style.display === 'flex' ||
                        document.getElementById('pre-workout-overlay').style.display === 'flex';

                    if (window.scrollY === 0 && !isBlockingOverlay) {
                        startY = e.touches[0].clientY;
                        isDragging = true;
                    }
                }, { passive: true });

                document.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    const y = e.touches[0].clientY;
                    const diff = y - startY;

                    if (diff > 0 && window.scrollY <= 0) {
                        // Pulling down
                        ptr.style.top = (diff / 3.0 - 60) + 'px'; // Increased resistance slightly
                        const icon = document.getElementById('ptr-icon');
                        if (diff > threshold) {
                            icon.style.transform = 'rotate(180deg)';
                            icon.innerText = "🔄";
                        } else {
                            icon.style.transform = 'rotate(0deg)';
                            icon.innerText = "⬇️";
                        }
                    } else {
                        isDragging = false; // Scrolled down
                    }
                }, { passive: true });

                document.addEventListener('touchend', (e) => {
                    if (!isDragging) return;
                    isDragging = false;
                    const y = e.changedTouches[0].clientY;
                    const diff = y - startY;

                    if (diff > threshold && window.scrollY <= 0) {
                        // Trigger Refresh Check
                        if (confirm("Weet je zeker dat je de pagina wilt verversen? \n(De huidige training stopt dan)")) {
                            ptr.className = 'ptr-refreshing';
                            location.reload();
                        } else {
                            // Cancel
                            ptr.style.top = '-60px';
                        }
                    } else {
                        // Reset
                        ptr.style.top = '-60px';
                    }
                });
            })();

            // --- CLICK OUTSIDE TO CLOSE AUDIO SETTINGS ---
            document.addEventListener('click', (e) => {
                const panel = document.getElementById('active-volume-panel');
                const btn = document.getElementById('global-volume-btn');

                if (panel && panel.style.display !== 'none') {
                    // Check if click is OUTSIDE panel AND OUTSIDE trigger button
                    if (!panel.contains(e.target) && !btn.contains(e.target)) {
                        panel.style.display = 'none';
                    }
                }
            });

        </script>

        <!-- AUDIO GUIDE POPUP -->



    </div> <!-- Close pre-workout-overlay -->

    <!-- GLOBAL VOLUME TOGGLE BTN (Relocated & HIGH Z-INDEX) -->
    <div id="global-fullscreen-btn"
        style="position:fixed; top:20px; right:75px; z-index:200000; background:rgba(0,0,0,0.6); width:44px; height:44px; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer; border:1px solid rgba(255,255,255,0.5); backdrop-filter:blur(10px); color:white; box-shadow:0 4px 12px rgba(0,0,0,0.3);"
        onclick="toggleFullScreen()">
        <span style="font-size:20px;">⛶</span>
    </div>

    <div id="global-volume-btn"
        style="position:fixed; top:20px; right:20px; z-index:200000; background:rgba(0,0,0,0.6); width:44px; height:44px; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer; border:1px solid rgba(255,255,255,0.5); backdrop-filter:blur(10px); color:white; box-shadow:0 4px 12px rgba(0,0,0,0.3);"
        onclick="toggleVolumePanel()">
        <span style="font-size:20px;">🔊</span>
    </div>

    <!-- VOLUME PANEL OVERLAY (Relocated to Body) -->
    <div id="active-volume-panel"
        style="display:none; position:fixed; top:70px; right:20px; width:280px; max-height:80vh; overflow-y:auto; scrollbar-width:none; -ms-overflow-style:none; background:rgba(28, 28, 30, 0.95); backdrop-filter:blur(20px); -webkit-backdrop-filter:blur(20px); padding:15px; border-radius:20px; border:1px solid rgba(255,255,255,0.2); z-index:200001; box-shadow:0 30px 60px rgba(0,0,0,0.8);">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:15px;">
            <span style="font-size:13px; color:#fff; font-weight:bold; letter-spacing:0.5px;">AUDIO SETTINGS</span>
            <span style="font-size:24px; cursor:pointer; opacity:0.6;" onclick="toggleVolumePanel()">×</span>
        </div>

        <!-- Playback Controls -->
        <div
            style="display:flex; align-items:center; justify-content:center; gap:25px; margin-bottom:25px; background:rgba(255,255,255,0.05); padding:10px; border-radius:15px;">
            <div onclick="bgMusicManager.playPrevious()" style="cursor:pointer; font-size:20px; opacity:0.8;">⏮️</div>
            <div onclick="bgMusicManager.togglePlayback()"
                style="cursor:pointer; font-size:28px; transform:scale(1.1);">⏯️</div>
            <div onclick="bgMusicManager.playNext()" style="cursor:pointer; font-size:20px; opacity:0.8;">⏭️</div>
        </div>

        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:20px;">
            <span style="font-size:16px; min-width:30px;">🎵</span>
            <div style="flex:1; margin:0 10px; display:flex; flex-direction:column;">
                <span style="font-size:10px; color:#aaa; margin-bottom:4px; font-weight:bold;">WERK MUZIEK</span>
                <input type="range" id="vol-music-live" min="0" max="1" step="0.1" value="0.4"
                    style="width:100%; accent-color:#30D158;" oninput="updateLiveVolumes()">
            </div>

        </div>

        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:20px;">
            <span style="font-size:16px; min-width:30px;">🧘</span>
            <div style="flex:1; margin:0 10px; display:flex; flex-direction:column;">
                <span style="font-size:10px; color:#aaa; margin-bottom:4px; font-weight:bold;">RUST MUZIEK</span>
                <input type="range" id="vol-music-rest-live" min="0" max="1" step="0.1" value="0.2"
                    style="width:100%; accent-color:#FF9F0A;" oninput="updateLiveVolumes()">
            </div>

        </div>

        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:20px;">
            <span style="font-size:16px; min-width:30px;">🗣️</span>
            <div style="flex:1; margin:0 10px; display:flex; flex-direction:column;">
                <span style="font-size:10px; color:#aaa; margin-bottom:4px; font-weight:bold;">COACH VOLUME</span>
                <input type="range" id="vol-coach-live" min="0" max="1" step="0.1" value="1.0"
                    style="width:100%; accent-color:#0A84FF;" oninput="updateLiveVolumes()">
            </div>

        </div>

        <!-- COLLAPSIBLE AUDIO SETTINGS -->
        <!-- AUDIO SETTINGS (Always Visible) -->
        <div style="margin-top:15px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">

            <div style="margin-top:15px; padding-left:5px; padding-right:5px;">
                <!-- Continuous Mode Toggle -->
                <div
                    style="display:flex; align-items:center; justify-content:space-between; padding:15px; background:rgba(255,255,255,0.05); border-radius:12px; border:1px solid rgba(255,255,255,0.05);">
                    <div style="display:flex; flex-direction:column; text-align:left;">
                        <div style="font-size:13px; color:#fff; font-weight:bold;">🦾 Continuous Mode</div>
                        <div style="font-size:10px; color:#888; margin-top:2px;">Alleen werkmuziek (geen dip)</div>
                    </div>
                    <label class="switch" style="position:relative; display:inline-block; width:40px; height:24px;">
                        <input type="checkbox" id="chk-continuous-music"
                            onchange="bgMusicManager.setContinuous(this.checked)">
                        <span class="slider round"
                            style="position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background-color:#444; transition:.4s; border-radius:34px;"></span>
                        <style>
                            .slider:before {
                                position: absolute;
                                content: "";
                                height: 18px;
                                width: 18px;
                                left: 3px;
                                bottom: 3px;
                                background-color: white;
                                transition: .4s;
                                border-radius: 50%;
                            }

                            input:checked+.slider {
                                background-color: #30D158;
                            }

                            input:checked+.slider:before {
                                transform: translateX(16px);
                            }
                        </style>
                    </label>
                </div>

                <!-- GENRE LIST CONTAINER (Reordered) -->
                <div id="audio-settings-genres"
                    style="margin-top:15px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px; max-height:200px; overflow-y:auto;">
                    <!-- Populated by renderGenreToggles -->
                </div>

                <!-- PLAYLIST VIEW (Reordered) -->
                <div id="playlist-view"
                    style="margin-top:15px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px; max-height:150px; overflow-y:auto;">
                    <div id="gym-now-playing"
                        style="font-size:11px; color:#30D158; font-weight:bold; margin-bottom:5px;">
                        Now Playing: -</div>
                    <div id="gym-queue-list" style="font-size:10px; color:#666;">
                        <!-- Queue items populated by JS -->
                    </div>
                </div>

                <!-- COACH SETTINGS (Reordered) -->
                <div style="border-top:1px solid rgba(255,255,255,0.1); margin-top:15px; padding-top:15px;">
                    <div
                        style="font-size:11px; font-weight:900; color:#666; margin-bottom:10px; text-transform:uppercase;">
                        COACH TYPE</div>

                    <div style="display:flex; gap:10px; margin-bottom:10px;">
                        <button class="toggle-btn active" id="btn-audio-speech-live"
                            onclick="setAudioMode('speech'); updateLiveAudioUI();"
                            style="flex:1; padding:8px; font-size:11px;">🗣️ SPRAAK</button>
                        <button class="toggle-btn" id="btn-audio-beep-live"
                            onclick="setAudioMode('beep'); updateLiveAudioUI();"
                            style="flex:1; padding:8px; font-size:11px;">🔔 PIEPJES</button>
                    </div>

                    <select id="coach-preset-live" class="text-input"
                        onchange="applyCoachPreset(this.value); saveToLocal();"
                        style="width:100%; font-size:13px; padding:10px; margin-bottom:10px; background:rgba(0,0,0,0.3); border-radius:10px;">
                        <!-- Populated via JS -->
                    </select>

                    <!-- SPEECH TOGGLES (Detailed) -->
                    <div id="audio-toggles-panel"
                        style="margin-top:10px; padding-top:5px; border-top:1px solid rgba(255,255,255,0.05);">
                        <!-- Populated by renderAudioToggles -->
                    </div>
                </div>


            </div>
        </div>
    </div>
    </div>
</body>

</html>